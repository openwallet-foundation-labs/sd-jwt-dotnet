# Beyond Redaction: Scaling Privacy-Preserving GenAI with SD-JWTs

**By [Your Name]**

In the race to deploy Generative AI, the "Hello World" phase is over. Engineering teams are now tackling the "Day 2" reality: how to make these systems useful in highly regulated industries without creating a data privacy nightmare.

Consider the Australian Superannuation industry. Members are demanding more than static dashboards; they want personalized, conversational guidance. They want to ask: *"Should I salary sacrifice this year?"*

To answer these questions, an LLM needs context. Historically, this meant retrieving a memberâ€™s **"Golden Record"**â€”a monolithic data structure containing everything from their home address to their beneficiary history. But feeding this entire record into an LLM context window is a non-starter for security and compliance.

This article explores a robust architectural pattern we can use to solve this: **Selective Disclosure JSON Web Tokens (SD-JWT)**. By deconstructing the Golden Record and moving from simple redaction to cryptographic selective disclosure, we can build AI agents that are context-aware yet privacy-preserving by design.

---

## Background: The "Golden Record" Paradox

To understand the security challenge, we first need to look at the data topology of a typical registry system.

In legacy architectures, member data is often stored as a tightly coupled, monolithic object. When a backend service requests "Member Details," it receives the entire blob. While efficient for traditional web apps, this structure is toxic for GenAI.

To give accurate financial advice, we need to separate the **"Who"** from the **"What."**

### The Data Coupling Issue
We classify member data into two distinct buckets based on their utility to the AI and their risk to the business:

| Data Class | Definition | Superannuation Examples |
| :--- | :--- | :--- |
| **Identity PII** | **The "Who"** (Toxic) | Tax File Number (TFN), Full Name, Address, DOB. Leakage here is a reportable breach. |
| **Financial State** | **The "What"** (Useful) | Account Balance, Cap Room, Admin Fees. Essential for personalizing the calculation. |

**The Architecture Gap:**
To answer a question like *"Can I afford to contribute more?"*, the AI Agent requires the **Financial State**. However, because of the Golden Record structure, most APIs force developers to fetch the **Identity PII** simultaneously. You cannot get the "Cap Room" without also getting the "TFN".

![Figure 1: The Golden Record Problem - Visualizing how Identity PII binds to Financial State](placeholder-url)
*Figure 1: The Golden Record binds Identity PII to Financial State. Standard integration patterns force us to fetch both, creating a privacy risk.*

---

## The Problem: The "All-or-Nothing" Dilemma

When engineers try to bridge this gap, they usually face three bad options.

1.  **The "Full Context" Injection:** Dumping the full profile into the Prompt. This is oversharing by default.
2.  **User-Driven Input:** Asking the user to type their balance. This creates "garbage in, garbage out" scenarios where the AI trusts typos.
3.  **Middleware Redaction:** Using Regex to strip TFNs. This is fragile; as schemas change, redaction rules break, and there is no cryptographic proof that the remaining data is authentic.

---

## The Solution: Selective Disclosure (SD-JWT)

The industry is coalescing around a new standard to solve this: **SD-JWT (IETF RFC 9901)**.

SD-JWT allows us to sign a JSON object but enables the client to reveal only specific fields to a server while maintaining the validity of the original signature.

Think of it as a **Verified Financial Snapshot**. The Registry signs a statement containing *all* member facts. However, the application layer can selectively reveal *only* the **Financial State**, keeping **Identity PII** cryptographically hidden from the AI.

---

## Architecture: The "Verified Snapshot" Workflow

To implement this, we shift the architecture from a server-centric model to a user-centric model. We utilize the **OpenID4VCI** protocol for issuance and **OpenID4VP** for presentation.

<div class="mermaid">
sequenceDiagram
    participant Registry as Registry (Source)
    participant Issuer as Identity Provider
    participant App as Mobile App (Holder)
    participant Verifier as AI Service
    participant LLM as GenAI Model

    Note over Registry, App: Step 1: Issuance (OpenID4VCI)
    App->>Issuer: Request "Financial Snapshot"
    Issuer->>Registry: Fetch Golden Record
    Issuer->>App: Issue SD-JWT (Salted & Hashed)
    
    Note over App, Verifier: Step 2: Storage
    App->>App: Store Credential in Secure Enclave
    
    Note over App, LLM: Step 3: Interaction
    App->>Verifier: "Should I salary sacrifice?"
    Verifier->>LLM: Classify Intent
    LLM-->>Verifier: INTENT: CONTRIBUTION_STRATEGY
    
    Note over Verifier, App: Step 4: Selective Presentation
    Verifier->>App: Request Claims: [balance, cap_remaining]
    App->>Verifier: Verifiable Presentation (No TFN, No Name)
    
    Note over Verifier, LLM: Step 5: Verification & Advice
    Verifier->>Verifier: Verify Signature & Hashes
    Verifier->>LLM: Prompt with Verified Context
    LLM-->>App: Personalized Advice
</div>

### Step 1: Issuance (OpenID4VCI)
*How the App gets the data*

We don't build custom APIs to fetch these tokens. We use **OpenID for Verifiable Credential Issuance (OpenID4VCI)**.
* The Member logs into the App via standard OIDC (e.g., Auth0/IdentityServer).
* The App requests a `financial_snapshot_credential`.
* The **Issuer** wraps the Registry data in an SD-JWT, salts the sensitive fields, and delivers it to the App.
* **Why this matters:** OpenID4VCI standardizes how wallets and apps negotiate authentication and encryption, ensuring the token is delivered securely to the right device.

### Step 2: Storage (The Holder)
The Credential is sent to the **Mobile App**, which stores it in secure storage. The member's device now holds the "truth," removing the need for a persistent backend session cache.

### Step 3: Intent Classification (The Verifier)
*How the AI translates "Human Speak" into "Protocol Speak"*

The AI Service doesn't magically know which fields to fetch. We use a two-step process: **Intent Classification** followed by **Schema Mapping**.

1.  **The Classifier:** When the user asks *"Should I salary sacrifice?"*, a lightweight LLM (like GPT-4o-mini) analyzes the text. It doesn't generate advice yet; it only outputs a classification tag.
    * *Output:* `INTENT: CONTRIBUTION_STRATEGY`

2.  **The Mapper:** The backend maintains a **Presentation Definition** (standardized in **OpenID4VP**) for each intent. This looks up the specific data requirements.

    | Intent Tag | Required Claims (The "Must Haves") |
    | :--- | :--- |
    | `CONTRIBUTION_STRATEGY` | `balance`, `concessional_cap_remaining` |

**The Handshake:**
The AI Service sends an Authorization Request to the App:
> *"I need you to present a valid credential issued by [Fund Name]. I specifically need the fields: `balance` and `cap_remaining`."*

### Step 4: Selective Presentation (The Holder)
*What actually gets sent across the wire*

The App receives the request. If the user approves, the App uses the **SdJwt.Net** library to generate a response.

Crucially, the App does **not** send a plain JSON file. It sends a **Verifiable Presentation (VP)**, which contains:
1.  **The Signed Wrapper:** The original signature from the Fund.
2.  **The Disclosures:** The specific values the user chose to reveal (e.g., "$50,000"), along with the cryptographic "salt."

**What is EXCLUDED:**
The App explicitly **omits** the disclosures for TFN, Name, and Address. The AI Service sees only opaque strings for these fields.

### Step 5: Verification & Advice
The AI Service receives the presentation.
* It verifies the signature matches the **Issuer** (The Fund).
* It hashes the disclosed values to ensure they match the signed digest.
* It feeds the verified numbers into the LLM context to generate the final advice.

---

## Advanced Architecture: Federation & Revocation

In a real-world Superannuation ecosystem, two critical problems remain: **Trust** (How does the AI know the Issuer is legitimate?) and **Revocation** (What if the member leaves the fund?).

### Scaling Trust: OpenID Federation
The Superannuation industry is fragmented. There are many Funds and many AI providers. If an AI agent receives a token signed by `https://issuer.example.com`, how does it know that issuer is a licensed Super Fund and not a phishing site?

We solve this with **OpenID Federation**.
* **The Trust Chain:** We don't hardcode keys. Instead, the AI Service checks a "Trust Anchor" (e.g., a regulator or industry gateway).
* **The Lookup:** The Trust Anchor publishes a signed list of valid Issuers.
* **The Result:** When the AI verifies the SD-JWT, it also traverses the Federation chain. It confirms: *"This token was signed by BigFund, and BigFund is currently licensed by the Regulator."*

### Handling Exits: Token Status List
Financial data is volatile. A member might roll over their balance to a new fund, or an account might be flagged for fraud. If the SD-JWT on the phone is valid for 30 days, we have a security gap.

We address this with **Token Status List** (a standard mechanism for high-scale revocation).
1.  **The Bitstring:** The Issuer publishes a small file (a bitstring) hosted on a CDN.
2.  **The Index:** Inside the SD-JWT, there is a pointer: `status_list: { idx: 4502 }`.
3.  **The Check:** During verification (Step 5), the AI Service fetches the Status List and checks the bit at position `4502`.
    * `0` = Valid.
    * `1` = Revoked.
4.  **The Impact:** This allows the Fund to revoke a specific credential instantly without needing to contact the user's phone.

---

## Deep Dive: Handling Multi-Turn Conversations

Members rarely ask one question and stop. A typical session is a chain of evolving context:

> **Turn 1:** "Should I salary sacrifice?"
> **Turn 2:** "Ok. If I add $200 per fortnight, does that change my insurance?"

In a traditional architecture, the AI backend maintains a growing session state. With SD-JWT, we use **Progressive Disclosure**.

* **Turn 1:** AI requests `Balance`. App generates **VP #1**. AI gives advice and discards the data.
* **Turn 2:** AI requests `Insurance_Premiums`. The AI *does not* go back to the Registry. It asks the App again. The App generates **VP #2** from the *same* cached Credential.

This keeps the context window small, clean, and strictly focused on the current question.

---

## Security Deep Dive: Why Auditors Trust Client-Side Data

For an auditor, the "proof" is the **Verifiable Presentation (VP)**. This provides three layers of cryptographic guarantees:

1.  **Proof of Origin:** The **Issuer Signature** proves the data came from the Fund.
2.  **Proof of Integrity:** The **Salted Hashes** prove the values haven't been tampered with.
3.  **Proof of Possession:** **Key Binding** proves the request came from the user's secure device.

### The "Notary" Analogy
Think of the **Registry** as a **Notary**.
1.  The Notary writes a document listing your assets, puts it in a **glass box**, and seals it.
2.  They give the box to **You** (The User).

When you go to the AI Service, you cannot open the box to change the numbers without breaking the seal. You simply show the box. The Auditor doesn't need to trust you; they only need to verify the Notary's seal is unbroken.

---

## UX Design: The "Consent Receipt"

The success of this architecture depends on the user interface. If users feel overwhelmed by permissions, they will opt out. We recommend a **"Just-in-Time" Consent Sheet** pattern.

![Figure 2: Mobile UI Placeholder - A Consent Sheet sliding up](placeholder-url)

* **The Trigger:** Don't ask for permission at login. Wait until the user asks the question.
* **The Receipt:** A modal slides up showing clearly what is being shared (e.g., âœ… Account Balance) and what is being hidden (e.g., ðŸš« Identity).
* **The Loop:** Once the user taps "Share," the sheet closes, and the answer streams immediately. For subsequent questions in the same session, the App can implicitly trust the intent, making the multi-turn flow feel seamless.

---

## Conclusion

The transition from AI prototypes to production requires a fundamental shift in how we handle data. We cannot rely on policy documents or fragile redaction code to protect user privacy. We need architectural guarantees.

By combining **SD-JWT** for selective disclosure, **OpenID4VCI** for standardized issuance, and **OpenID Federation** for ecosystem trust, we can feed GenAI engines the fuel they need without burning down the privacy fence.

In the next article of this series, we will dive into the code. We will demonstrate how to implement this workflow in .NET using the **SdJwt.Net** library.

### See Also
* **SdJwt.Net on GitHub:** [Link]
* **IETF RFC 9901:** Selective Disclosure for JWTs
* **OpenID4VCI:** Credential Issuance Specification
* **OpenID Federation:** Trust Ecosystems

*Tags: #GenAI #Privacy #Security #DotNet #SDJWT #DigitalIdentity*