{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SD-JWT .NET Documentation","text":"<p>Welcome to the comprehensive documentation for the SD-JWT .NET ecosystem\u2014a highly modular, production-ready implementation of Selective Disclosure JSON Web Tokens (RFC 9901) and the OpenID for Verifiable Credentials (OpenID4VC) stack.</p> <p>This documentation is organized around the Di\u00e1taxis framework, splitting content into four distinct categories based on your immediate needs:</p>"},{"location":"#1-getting-started-tutorials","title":"\ud83d\ude80 1. Getting Started (Tutorials)","text":"<p>Learning-oriented. Goal: Get you up and running successfully in 15 minutes.</p> <ul> <li>15-Minute Quickstart: Build your first Issuer, Wallet, and Verifier in a single console application.</li> <li>Running the Sample Architecture: How to launch and play with our interactive CLI that demonstrates all packages working together.</li> </ul>"},{"location":"#2-how-to-guides","title":"\ud83d\udee0 2. How-To Guides","text":"<p>Problem-oriented. Goal: Practical, step-by-step guides for solving specific problems using the ecosystem packages.</p> <ul> <li>How to Issue Verifiable Credentials: Setting up an <code>Oid4Vci</code> Issuer to mint W3C-compliant SD-JWTs.</li> <li>How to Verify Presentations: Configuring a Relying Party to request specific data using Presentation Exchange.</li> <li>How to Manage Credential Revocation: Implementing privacy-preserving Status Lists.</li> <li>How to Establish Trust: Using OpenID Federation to dynamically resolve Trust Chains.</li> </ul>"},{"location":"#3-concepts","title":"\ud83e\udde0 3. Concepts","text":"<p>Understanding-oriented. Goal: Deep architectural dives, diagrams, and \"Why\" explanations.</p> <ul> <li>Ecosystem Architecture: The master architectural overview mapping out the Protocol, Policy, and Core layers.</li> <li>HAIP Compliance: Understanding the High Assurance Interoperability Profile levels and automated compliance enforcement.</li> <li>Selective Disclosure Mechanics: A deep dive into exactly how salts, hashes, and Key Binding JWTs work under the hood.</li> </ul>"},{"location":"#4-insights-reference","title":"\ud83d\udca1 4. Insights &amp; Reference","text":"<p>Ecosystem patterns, thought leadership, and advanced use cases.</p> <ul> <li>AI Financial Co-Pilot: Utilizing LLMs with zero-knowledge data retrieval.</li> <li>Automated Compliance &amp; Data Minimization: AI-driven Presentation Definition interception.</li> <li>Quantum Key Distribution (QKD): Securing sovereign trust anchors with post-quantum cryptography.</li> <li>Automated Incident Response: Zero-day containment using webhooks and Status Lists.</li> <li>Versioning Strategy: Our automated Semantic Versioning pipeline.</li> </ul>"},{"location":"#api-package-reference","title":"\ud83d\udce6 API &amp; Package Reference","text":"<p>For detailed API references and code documentation for individual NuGet packages, see the respective source code directories:</p> <ul> <li><code>SdJwt.Net</code></li> <li><code>SdJwt.Net.Vc</code></li> <li><code>SdJwt.Net.Oid4Vci</code></li> <li><code>SdJwt.Net.Oid4Vp</code></li> <li><code>SdJwt.Net.PresentationExchange</code></li> <li><code>SdJwt.Net.StatusList</code></li> <li><code>SdJwt.Net.OidFederation</code></li> <li><code>SdJwt.Net.HAIP</code></li> </ul>"},{"location":"concepts/architecture/","title":"SD-JWT .NET Ecosystem Architecture","text":""},{"location":"concepts/architecture/#executive-summary","title":"Executive Summary","text":"<p>The <code>SdJwt.Net</code> ecosystem provides a comprehensive, modular implementation of the OpenID4VC (OpenID for Verifiable Credentials) specification suite. It is built natively for .NET, focusing on high-assurance security through the HAIP (High Assurance Interoperability Profile) framework.</p> <p>This architecture supports everything from simple educational credentials to Level 3 Sovereign government identity systems secured by Post-Quantum Cryptography.</p>"},{"location":"concepts/architecture/#high-level-system-architecture","title":"High-Level System Architecture","text":"<p>The ecosystem is divided into three distinct conceptual layers:</p> <ol> <li>Protocol Layer: How systems communicate (OID4VCI, OID4VP, Federation).</li> <li>Policy Layer: How security is enforced (HAIP Compliance Engine).</li> <li>Core Layer: How data is structured and signed (SD-JWT, W3C VC, Status Lists).</li> </ol> <pre><code>graph TB\n    subgraph \"Application Layer\"\n        WalletApp[Wallet Application]\n        IssuerApp[Issuer Application]\n        VerifierApp[Verifier Application]\n        GovApp[Government Portal]\n    end\n\n    subgraph \"SD-JWT .NET Ecosystem\"\n        subgraph \"Protocol Layer\"\n            OID4VCI[SdJwt.Net.Oid4Vci&lt;br/&gt;Issuance]\n            OID4VP[SdJwt.Net.Oid4Vp&lt;br/&gt;Presentation]\n            PE[SdJwt.Net.PresentationExchange&lt;br/&gt;Requirements]\n            Federation[SdJwt.Net.OidFederation&lt;br/&gt;Trust]\n        end\n\n        subgraph \"Policy Layer\"\n            HAIP[HAIP Compliance Engine&lt;br/&gt;Level 1/2/3]\n        end\n\n        subgraph \"Core Layer\"\n            SDJWT[SdJwt.Net Core&lt;br/&gt;Foundation]\n            VC[SdJwt.Net.Vc&lt;br/&gt;W3C Support]\n            Status[SdJwt.Net.StatusList&lt;br/&gt;Revocation]\n        end\n    end\n\n    WalletApp --&gt; OID4VP\n    WalletApp --&gt; OID4VCI\n    IssuerApp --&gt; OID4VCI\n    VerifierApp --&gt; OID4VP\n    GovApp --&gt; HAIP\n\n    OID4VCI --&gt; HAIP\n    OID4VP --&gt; HAIP\n    PE --&gt; HAIP\n    Federation --&gt; HAIP\n\n    HAIP --&gt; SDJWT\n    HAIP --&gt; VC\n    HAIP --&gt; Status</code></pre>"},{"location":"concepts/architecture/#core-design-principles","title":"Core Design Principles","text":""},{"location":"concepts/architecture/#1-modular-architecture","title":"1. Modular Architecture","text":"<p>Each NuGet package serves a specific purpose. You only pull in what you need. A backend issuing W3C credentials via custom REST APIs only needs <code>SdJwt.Net.Vc</code>, while a full OpenID provider would pull in <code>SdJwt.Net.Oid4Vci</code>.</p>"},{"location":"concepts/architecture/#2-policy-driven-security-haip","title":"2. Policy-Driven Security (HAIP)","text":"<p>Security is not left up to individual developers remembering to check algorithms or validate trust chains in their controllers. The HAIP Compliance Engine acts as a configurable policy layer that intercepts requests.</p> <pre><code>// Policy automatically applied via middleware/interceptors\nservices.AddSdJwtEcosystem(config =&gt;\n{\n    config.UseHaipProfile(HaipLevel.Level2_VeryHigh);\n    // Automatically enforces:\n    // - ES384+ algorithms only\n    // - Wallet attestation required\n    // - DPoP tokens required\n});\n</code></pre> <p>(Read more in the HAIP Compliance Concept Guide)</p>"},{"location":"concepts/architecture/#3-standards-compliance-first","title":"3. Standards Compliance First","text":"<p>The ecosystem strictly adheres to the latest working drafts and RFCs:</p> <ul> <li>IETF RFC 9901: Selective Disclosure for JWTs (SD-JWT)</li> <li>OpenID4VCI: Credential Issuance</li> <li>OpenID4VP: Credential Presentation</li> <li>W3C VC: Verifiable Credentials Data Model v2.0</li> <li>DIF PE: Presentation Exchange v2.0</li> <li>OpenID Federation: 1.0 Trust infrastructure</li> </ul>"},{"location":"concepts/architecture/#component-deep-dive","title":"Component Deep Dive","text":""},{"location":"concepts/architecture/#sdjwtnet-the-foundation","title":"SdJwt.Net (The Foundation)","text":"<p>Implements the core RFC 9901 specifications. It provides the <code>SdJwtBuilder</code> for generating the complex nested hashes and salts required for selective disclosure, and <code>SdJwtVerifier</code> for checking signatures and matching disclosure hashes. (Read more in the Selective Disclosure Mechanics Guide)</p>"},{"location":"concepts/architecture/#sdjwtnetvc-w3c-compliance","title":"SdJwt.Net.Vc (W3C Compliance)","text":"<p>Wraps the core library to enforce the strict JSON schema requirements of the W3C Verifiable Credentials data model (ensuring <code>@context</code>, <code>type</code>, <code>issuer</code>, and <code>credentialSubject</code> are properly formatted).</p>"},{"location":"concepts/architecture/#sdjwtnetoid4vci-issuance","title":"SdJwt.Net.Oid4Vci (Issuance)","text":"<p>Implements the OAuth 2.0 extension flows required for a Wallet to request credentials from an Issuer, including <code>.well-known</code> discovery, PAR (Pushed Authorization Requests), and DPoP (Demonstrating Proof-of-Possession).</p>"},{"location":"concepts/architecture/#sdjwtnetoid4vp-presentationexchange-verification","title":"SdJwt.Net.Oid4Vp &amp; PresentationExchange (Verification)","text":"<p>Allows Verifiers to request specific data points from a Wallet. The <code>PresentationExchangeEvaluator</code> parses complex JSON path constraints (e.g., \"User must be over 18 AND have a valid driver's license\").</p>"},{"location":"concepts/architecture/#sdjwtnetoidfederation-trust","title":"SdJwt.Net.OidFederation (Trust)","text":"<p>In zero-trust environments, how does a Verifier know an Issuer is real? This package implements Trust Chains. Entity Statements are resolved recursively up to a trusted Root Authority (like an eIDAS Trust Anchor or a National Government).</p>"},{"location":"concepts/architecture/#sdjwtnetstatuslist-revocation","title":"SdJwt.Net.StatusList (Revocation)","text":"<p>Verifiable Credentials cannot be \"un-issued\" once stored in a user's wallet. This package implements highly compressed bitstrings (often hosted on a CDN) that allow Verifiers to instantly check if a credential index has been revoked by the issuer, without sacrificing privacy.</p>"},{"location":"concepts/architecture/#deployment-topologies","title":"Deployment Topologies","text":"<p>The ecosystem is designed to scale from single monoliths to massive multi-tenant Sovereign gateways.</p>"},{"location":"concepts/architecture/#cloud-native-scalability","title":"Cloud-Native Scalability","text":"<p>Because SD-JWT operations are highly CPU-intensive (thousands of SHA-256 hashes for large disclosures) and require rapid trust resolution, the architecture supports multi-layer caching.</p> <pre><code>graph LR\n    Client([Incoming Request])\n\n    subgraph \"L1: In-Process\"\n        L1[Memory Cache&lt;br/&gt;15min TTL&lt;br/&gt;~microseconds]\n    end\n\n    subgraph \"L2: Distributed\"\n        L2[Redis Cache&lt;br/&gt;1-2hr TTL&lt;br/&gt;~milliseconds]\n    end\n\n    subgraph \"L3: CDN Edge\"\n        L3[CDN Cache&lt;br/&gt;Status Lists&lt;br/&gt;Public data only]\n    end\n\n    Client --&gt; L1\n    L1 --&gt;|miss| L2\n    L2 --&gt;|miss| L3</code></pre> <p>By utilizing <code>ObjectPools</code> for ECDSA/RSA cryptographic providers and heavy memory caching for resolved Federation Trust Chains, the .NET implementation is designed for maximum throughput.</p>"},{"location":"concepts/haip-compliance/","title":"High Assurance Interoperability Profile (HAIP) Compliance","text":""},{"location":"concepts/haip-compliance/#overview","title":"Overview","text":"<p>The High Assurance Interoperability Profile (HAIP) acts as a configurable policy and enforcement layer on top of the base SD-JWT and OpenID4VC protocols. It ensures that deployments meet the stringent cryptographic, transport, and trust requirements of highly regulated environments.</p> <p>Rather than relying on developers to manually check every algorithm, signature, and trust chain in their business logic, HAIP intercepts requests at the protocol boundary and enforces a predefined security posture.</p>"},{"location":"concepts/haip-compliance/#the-haip-policy-engine","title":"The HAIP Policy Engine","text":"<p>HAIP implements a pluggable policy engine that validates incoming and outgoing requests against strict compliance requirements.</p> <pre><code>public class HaipPolicyEngine\n{\n    private readonly IEnumerable&lt;IHaipValidator&gt; _validators;\n\n    public async Task&lt;HaipComplianceResult&gt; ValidateAsync(\n        object request, \n        HaipLevel requiredLevel)\n    {\n        var violations = new List&lt;HaipViolation&gt;();\n        var auditSteps = new List&lt;AuditStep&gt;();\n\n        foreach (var validator in _validators)\n        {\n            var result = await validator.ValidateAsync(request, requiredLevel);\n            violations.AddRange(result.Violations);\n            auditSteps.AddRange(result.AuditSteps);\n        }\n\n        return new HaipComplianceResult\n        {\n            IsCompliant = violations.Count == 0,\n            AchievedLevel = CalculateAchievedLevel(violations),\n            Violations = violations,\n            AuditTrail = new HaipAuditTrail { Steps = auditSteps }\n        };\n    }\n}\n</code></pre>"},{"location":"concepts/haip-compliance/#validator-architecture","title":"Validator Architecture","text":"<p>The policy engine relies on a suite of specialized validators.</p> <pre><code>classDiagram\n    class IHaipValidator {\n        &lt;&lt;interface&gt;&gt;\n        +ValidateAsync(request, level) HaipValidationResult\n    }\n\n    class HaipCryptoValidator {\n        +ValidateKeyCompliance()\n        +ValidateAlgorithm()\n        +ValidateKeyStrength()\n    }\n\n    class HaipProtocolValidator {\n        +ValidateProofOfPossession()\n        +ValidateSecureTransport()\n        +ValidateWalletAttestation()\n    }\n\n    class HaipTrustValidator {\n        +ValidateTrustChain()\n        +ValidateIssuerCompliance()\n        +ValidateTrustFramework()\n    }\n\n    class HaipAuditValidator {\n        +ValidateAuditRequirements()\n        +GenerateAuditRecord()\n        +ValidateSignatures()\n    }\n\n    IHaipValidator &lt;|-- HaipCryptoValidator\n    IHaipValidator &lt;|-- HaipProtocolValidator\n    IHaipValidator &lt;|-- HaipTrustValidator\n    IHaipValidator &lt;|-- HaipAuditValidator</code></pre>"},{"location":"concepts/haip-compliance/#progressive-compliance-levels","title":"Progressive Compliance Levels","text":"<p>HAIP defines three progressive levels of security assurance:</p> <pre><code>public enum HaipLevel\n{\n    Level1_High,        // Education, standard business\n    Level2_VeryHigh,    // Financial, healthcare\n    Level3_Sovereign    // Government, critical infrastructure\n}\n</code></pre>"},{"location":"concepts/haip-compliance/#level-1-high-eg-education-standard-business","title":"Level 1: High (e.g., Education, Standard Business)","text":"<ul> <li>Allowed Algorithms: <code>ES256</code>, <code>ES384</code>, <code>PS256</code>, <code>PS384</code>, <code>EdDSA</code></li> <li>Minimum Key Size: EC 256, RSA 2048</li> <li>Requirements: Proof of Possession, Secure Transport (TLS)</li> </ul>"},{"location":"concepts/haip-compliance/#level-2-very-high-eg-financial-healthcare","title":"Level 2: Very High (e.g., Financial, Healthcare)","text":"<ul> <li>Allowed Algorithms: <code>ES384</code>, <code>ES512</code>, <code>PS384</code>, <code>PS512</code>, <code>EdDSA</code></li> <li>Minimum Key Size: EC 384, RSA 3072</li> <li>Requirements: All Level 1, plus Wallet Attestation, DPoP, Pushed Authorization Requests (PAR)</li> </ul>"},{"location":"concepts/haip-compliance/#level-3-sovereign-eg-government-national-id","title":"Level 3: Sovereign (e.g., Government, National ID)","text":"<ul> <li>Allowed Algorithms: <code>ES512</code>, <code>PS512</code>, <code>EdDSA</code> (and emerging PQC algorithms)</li> <li>Minimum Key Size: EC 521, RSA 4096</li> <li>Requirements: All Level 2, plus Hardware Security Module (HSM) backing, Qualified Signatures, Enhanced Device Attestation</li> </ul>"},{"location":"concepts/haip-compliance/#integrating-haip","title":"Integrating HAIP","text":"<p>HAIP is designed for non-intrusive integration. Once configured in the Dependency Injection container, it enforces policies transparently across OID4VCI and OID4VP operations.</p> <pre><code>// Global Policy Application\nservices.AddSdJwtEcosystem(config =&gt;\n{\n    config.UseHaipProfile(HaipLevel.Level2_VeryHigh);\n\n    // All OID4VCI / OID4VP operations now enforce Level 2 requirements:\n    // - ES384+ algorithms only\n    // - Wallet attestation required\n    // - DPoP tokens required\n    // - Enhanced audit logging\n});\n</code></pre>"},{"location":"concepts/selective-disclosure-mechanics/","title":"Selective Disclosure Mechanics in SD-JWT","text":""},{"location":"concepts/selective-disclosure-mechanics/#the-core-concept","title":"The Core Concept","text":"<p>Traditional JSON Web Tokens (JWTs) suffer from an all-or-nothing privacy problem. If a Verifier requests proof of age, they must receive the entire JWT payload, potentially exposing irrelevant attributes like <code>home_address</code> or <code>blood_type</code>.</p> <p>Selective Disclosure for JWTs (SD-JWT), defined in IETF RFC 9901, solves this by separating the claims from the signature.</p> <p>Instead of signing the plain text claims directly, an SD-JWT signs cryptographically salted hashes of the claims. The actual data is provided separately in a \"disclosure array\". When presenting the token to a Verifier, the Holder only sends the disclosures for the claims they wish to reveal. The Verifier hashes the provided disclosures and verifies they match the hashes embedded in the signed token.</p>"},{"location":"concepts/selective-disclosure-mechanics/#how-it-works-the-sdjwtnet-implementation","title":"How it works (The <code>SdJwt.Net</code> Implementation)","text":""},{"location":"concepts/selective-disclosure-mechanics/#1-issuance-the-issuer","title":"1. Issuance (The Issuer)","text":"<p>When generating an SD-JWT using the <code>SdJwtBuilder</code>, the library performs the following steps for each selective claim:</p> <ol> <li>Generate a cryptographic salt: A high-entropy random string (e.g., 128-bit) is generated.</li> <li>Create a disclosure string: A JSON array containing the salt, the claim name, and the claim value: <code>[\"_26bc4LT-ac6q2KI6sBAceg\", \"email\", \"john@example.com\"]</code>.</li> <li>Hash the disclosure: The array is hashed using a strong algorithm (e.g., SHA-256) and Base64Url encoded.</li> <li>Embed the hash: The hash is embedded into the JWT payload under the special <code>_sd</code> array.</li> <li>Sign the JWT: The JWT is signed as normal.</li> </ol> <pre><code>// Example using SdJwt.Net Core\nvar builder = new SdJwtBuilder()\n    .WithClaim(\"name\", \"John Doe\")                    // Always visible (plain text)\n    .WithSelectiveDisclosureClaim(\"email\", \"john@example.com\")  // Hidden behind a hash\n    .WithSelectiveDisclosureClaim(\"age\", 30);         // Hidden behind a hash\n\nvar sdJwtString = await builder.CreateSdJwtAsync(signingKey);\n</code></pre>"},{"location":"concepts/selective-disclosure-mechanics/#2-the-issued-format-the-wallet","title":"2. The Issued Format (The Wallet)","text":"<p>The resulting <code>sdJwtString</code> string returned to the Wallet contains three parts separated by tildes (<code>~</code>):</p> <p><code>{JWT_Header}.{JWT_Payload}.{JWT_Signature}~{Disclosure1}~{Disclosure2}~</code></p> <p>The <code>{JWT_Payload}</code> might look like this:</p> <pre><code>{\n  \"iss\": \"https://issuer.example.com\",\n  \"name\": \"John Doe\",\n  \"_sd\": [\n    \"V8x1q...hash_for_email...q2A\", \n    \"xF9b...hash_for_age...Z8c\"\n  ]\n}\n</code></pre> <p>Notice the <code>email</code> and <code>age</code> are nowhere to be found in the actual JWT. The Wallet holds the disclosures separately.</p>"},{"location":"concepts/selective-disclosure-mechanics/#3-presentation-the-holder","title":"3. Presentation (The Holder)","text":"<p>When a Verifier requests the user's email, the Wallet creates a Presentation. The Wallet drops the disclosure string for <code>age</code> and only sends the disclosure string for <code>email</code>.</p> <pre><code>var presentation = SdJwtPresentation.Parse(sdJwtString)\n    .RevealClaim(\"email\")      // Include this disclosure\n    .HideClaim(\"age\")          // Omit this disclosure\n    .AddKeyBinding(\"audience_url\"); // Optional: Prove possession of the credential\n\nvar presentationString = presentation.ToString();\n// Format: {JWT}~{Disclosure_for_Email}~{Key_Binding_JWT}\n</code></pre>"},{"location":"concepts/selective-disclosure-mechanics/#4-verification-the-verifier","title":"4. Verification (The Verifier)","text":"<p>The <code>SdJwtVerifier</code> receives the presentation string and performs the inverse:</p> <ol> <li>Validates the Issuer's signature on the core JWT.</li> <li>For every disclosure provided in the string (e.g., the email disclosure), it hashes it.</li> <li>It checks if that calculated hash exists in the <code>_sd</code> array of the signed JWT payload.</li> <li>If it matches, the Verifier knows the Issuer originally attested to that exact <code>[salt, name, value]</code> combination!</li> </ol> <p>Because the <code>age</code> disclosure was not sent, the Verifier sees a hash in the <code>_sd</code> array but has no way to reverse-engineer it to determine the user's age.</p>"},{"location":"concepts/selective-disclosure-mechanics/#advanced-mechanics","title":"Advanced Mechanics","text":""},{"location":"concepts/selective-disclosure-mechanics/#key-binding-kb-jwt","title":"Key Binding (KB-JWT)","text":"<p>To prevent stolen token replay attacks, SD-JWT supports Key Binding. The Issuer binds the token to a public key held in the user's wallet (e.g., via the <code>cnf</code> claim).</p> <p>During presentation, the Wallet creates a new, short-lived JWT (the Key Binding JWT) signed by the Wallet's private key, proving to the Verifier that the presenter is the legitimate owner of the SD-JWT.</p>"},{"location":"concepts/selective-disclosure-mechanics/#decoy-hashes","title":"Decoy Hashes","text":"<p>To prevent a Verifier from inferring information based on the number of hidden claims (e.g., \"This person has 3 medical conditions listed\"), <code>SdJwt.Net</code> automatically injects random Decoy Hashes into the <code>_sd</code> array. These hashes do not correspond to any valid disclosure, obfuscating the true size of the credential.</p>"},{"location":"getting-started/quickstart/","title":"Quickstart: 15 Minutes to SD-JWT","text":"<p>This tutorial will get you up and running with the <code>SdJwt.Net</code> core library in under 15 minutes. We will act as all three parties (Issuer, Holder/Wallet, and Verifier) within a single console application.</p>"},{"location":"getting-started/quickstart/#1-create-a-new-project","title":"1. Create a New Project","text":"<p>Open your terminal and create a new .NET 8 or 9 Console Application:</p> <pre><code>dotnet new console -n SdJwtQuickstart\ncd SdJwtQuickstart\n</code></pre> <p>Install the core foundation package:</p> <pre><code>dotnet add package SdJwt.Net\n</code></pre>"},{"location":"getting-started/quickstart/#2-generate-cryptographic-keys","title":"2. Generate Cryptographic Keys","text":"<p>SD-JWTs require public key cryptography (like ECDSA or RSA) to sign the tokens. In a real application, the Issuer and the Verifier would have different keys, and the Wallet would have its own key for Key Binding.</p> <p>For this tutorial, open <code>Program.cs</code> and replace the contents with the following:</p> <pre><code>using System.Security.Cryptography;\nusing Microsoft.IdentityModel.Tokens;\nusing SdJwt.Net;\nusing System.Text.Json;\n\nConsole.WriteLine(\"--- SD-JWT Quickstart ---\");\n\n// 1. Generate keys for our actors\n// The Issuer signs the credential\nusing var issuerAlgorithm = ECDsa.Create(ECCurve.NamedCurves.nistP256);\nvar issuerKey = new ECDsaSecurityKey(issuerAlgorithm) { KeyId = \"issuer-key-1\" };\n\n// The Wallet signs a \"Proof of Possession\" during presentation\nusing var walletAlgorithm = ECDsa.Create(ECCurve.NamedCurves.nistP256);\nvar walletKey = new ECDsaSecurityKey(walletAlgorithm) { KeyId = \"wallet-key-1\" };\n</code></pre>"},{"location":"getting-started/quickstart/#3-the-issuer-creating-the-sd-jwt","title":"3. The Issuer: Creating the SD-JWT","text":"<p>The Issuer creates the credential using the <code>SdJwtBuilder</code>. We will add some plain-text claims that anyone can see, and some <code>SelectiveDisclosure</code> claims that are hidden behind cryptographic hashes.</p> <p>Append this to <code>Program.cs</code>:</p> <pre><code>Console.WriteLine(\"\\n[1] Issuer is building the SD-JWT...\");\n\nvar builder = new SdJwtBuilder()\n    .WithIssuer(\"https://issuer.example.com\")\n    .WithSubject(\"user123\")\n\n    // Always visible claims\n    .WithClaim(\"name\", \"Jane Doe\")\n    .WithClaim(\"nationality\", \"US\")\n\n    // Hidden claims (require user consent to reveal)\n    .WithSelectiveDisclosureClaim(\"email\", \"jane@example.com\")\n    .WithSelectiveDisclosureClaim(\"age\", 28)\n    .WithSelectiveDisclosureClaim(\"address\", \"123 Main St\")\n\n    // Bind the credential to the user's wallet key!\n    .WithConfirmationClaim(walletKey);\n\n// The Issuer signs the token using their private key\nvar sdJwtString = await builder.CreateSdJwtAsync(issuerKey);\n\nConsole.WriteLine(\"\\nRaw SD-JWT String (sent to wallet):\");\nConsole.WriteLine(sdJwtString);\n</code></pre> <p>Run the application (<code>dotnet run</code>). You will see a massive string separated by tildes (<code>~</code>).</p> <ul> <li>The first part is the signed JWT payload. Notice that the email, age, and address are not in the payload!</li> <li>The subsequent parts are the Disclosures (the salt + claim name + claim value).</li> </ul>"},{"location":"getting-started/quickstart/#4-the-wallet-creating-a-presentation","title":"4. The Wallet: Creating a Presentation","text":"<p>The Wallet has received the <code>sdJwtString</code> and stored it securely.</p> <p>Now, a Verifier (a website) asks the user for their email and age, but explicitly not their address or nationality.</p> <p>Append this to <code>Program.cs</code>:</p> <pre><code>Console.WriteLine(\"\\n[2] Wallet is creating a Presentation...\");\n\n// The wallet parses the massive string it received from the Issuer\nvar presentationBuilder = SdJwtPresentation.Parse(sdJwtString)\n\n    // The user explicitly consents to reveal these two claims\n    .RevealClaim(\"email\")\n    .RevealClaim(\"age\")\n\n    // The wallet drops the \"address\" disclosure\n    .HideClaim(\"address\")\n\n    // Provide Proof of Possession! \n    // The wallet creates a temporary \"Key Binding JWT\" signed with its own private key,\n    // proving the credential wasn't stolen.\n    .AddKeyBinding(new KeyBindingOptions\n    {\n        Audience = \"https://verifier.example.com\", // The website asking for data\n        Nonce = \"random-nonce-123\",                // To prevent replay attacks\n        SigningKey = walletKey                     // The wallet's private key\n    });\n\nvar presentationString = presentationBuilder.ToString();\n\nConsole.WriteLine(\"\\nPresentation String (sent to verifier):\");\nConsole.WriteLine(presentationString);\n</code></pre> <p>If you run the app again, you'll see the presentation string is slightly shorter than the original string\u2014that's because the Wallet intentionally dropped the disclosure containing the address!</p>"},{"location":"getting-started/quickstart/#5-the-verifier-validating-the-presentation","title":"5. The Verifier: Validating the Presentation","text":"<p>The Verifier receives the <code>presentationString</code> over an API endpoint. They must ensure it's authentic, untampered, and actually belongs to the user presenting it.</p> <p>Append this to <code>Program.cs</code>:</p> <pre><code>Console.WriteLine(\"\\n[3] Verifier is checking the Presentation...\");\n\nvar verifier = new SdJwtVerifier();\n\ntry\n{\n    // The verifier must know the Issuer's Public Key to verify the signature\n    var verificationResult = await verifier.VerifyAsync(\n        presentationToken: presentationString,\n        issuerPublicKey: issuerKey,\n        options: new VerificationOptions\n        {\n            ExpectedAudience = \"https://verifier.example.com\",\n            ExpectedNonce = \"random-nonce-123\"\n        });\n\n    Console.WriteLine($\"\\nIs Valid? {verificationResult.IsValid}\");\n\n    Console.WriteLine(\"\\nRevealed Claims:\");\n    foreach (var claim in verificationResult.RevealedClaims)\n    {\n        Console.WriteLine($\"- {claim.Key}: {claim.Value}\");\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"\\nVerification Failed: {ex.Message}\");\n}\n</code></pre>"},{"location":"getting-started/quickstart/#summary","title":"Summary","text":"<p>Run the application one last time. You have successfully:</p> <ol> <li>Acted as an Issuer to cryptographically salt and hide sensitive attributes.</li> <li>Acted as a Wallet to selectively reveal only a subset of those attributes while proving possession.</li> <li>Acted as a Verifier to cryptographically prove the data was authentic and untampered, without ever seeing the hidden attributes.</li> </ol>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>This tutorial demonstrated the core cryptographic engine. In a real-world scenario, you don't pass strings around via console variables\u2014you use HTTP protocols!</p> <ul> <li>To learn how to issue credentials over OAuth 2.0 (OpenID4VCI), read How to Issue Verifiable Credentials.</li> <li>To learn how to request and verify presentations over HTTP (OpenID4VP), read How to Verify Presentations.</li> </ul>"},{"location":"getting-started/running-the-samples/","title":"Getting Started with SD-JWT .NET Samples","text":"<p>This guide walks you through setting up and running the SD-JWT .NET samples, providing a hands-on introduction to selective disclosure and verifiable credentials.</p>"},{"location":"getting-started/running-the-samples/#prerequisites","title":"Prerequisites","text":""},{"location":"getting-started/running-the-samples/#development-environment","title":"Development Environment","text":"<ul> <li>.NET SDK 8.0 or 9.0: Download from Microsoft</li> <li>IDE: Visual Studio 2022/2026, VS Code, or JetBrains Rider</li> <li>Git: For cloning the repository</li> <li>Command Line: Terminal, PowerShell, or Command Prompt</li> </ul>"},{"location":"getting-started/running-the-samples/#optional-ai-integration","title":"Optional: AI Integration","text":"<p>For the Financial Co-Pilot scenario with real AI responses:</p> <ul> <li>OpenAI API Key: Get from OpenAI Platform</li> <li>Azure OpenAI (Alternative): Azure subscription with OpenAI service</li> </ul>"},{"location":"getting-started/running-the-samples/#quick-setup","title":"Quick Setup","text":""},{"location":"getting-started/running-the-samples/#1-clone-and-build","title":"1. Clone and Build","text":"<pre><code># Clone the repository\ngit clone https://github.com/openwallet-foundation-labs/sd-jwt-dotnet.git\ncd sd-jwt-dotnet\n\n# Restore dependencies and build\ndotnet restore\ndotnet build\n\n# Navigate to samples\ncd samples/SdJwt.Net.Samples\n</code></pre>"},{"location":"getting-started/running-the-samples/#2-run-interactive-samples","title":"2. Run Interactive Samples","text":"<pre><code># Start the interactive sample menu\ndotnet run\n</code></pre> <p>You'll see a menu like this:</p> <pre><code>==================================================================\n                    SD-JWT .NET Sample Explorer                    \n                         Comprehensive Demo                       \n==================================================================\n\nSAMPLE CATEGORIES:\n\nCORE FEATURES:\n1. Core SD-JWT Example\n2. JSON Serialization Example  \n3. Security Features Example\n\nVERIFIABLE CREDENTIALS:\n4. Verifiable Credentials Example\n5. Status Lists Example\n\nPROTOCOL INTEGRATION:\n6. OpenID4VCI Example\n7. OpenID4VP Example\n8. OpenID Federation Example\n9. Presentation Exchange Example\n\nADVANCED FEATURES:\nA. Comprehensive Integration Example\nB. Cross-Platform Features Example\n\nREAL-WORLD SCENARIOS:\nC. Real-World Use Cases\nF. Financial Co-Pilot (AI-Powered)\n\n0. Exit\n\nEnter your choice:\n</code></pre>"},{"location":"getting-started/running-the-samples/#3-start-with-basics","title":"3. Start with Basics","text":"<p>Begin with option 1 (Core SD-JWT Example) to understand fundamental concepts.</p>"},{"location":"getting-started/running-the-samples/#learning-progression","title":"Learning Progression","text":"<pre><code>flowchart LR\n    P1[Phase 1&lt;br/&gt;Core Concepts&lt;br/&gt;30 min] --&gt; P2[Phase 2&lt;br/&gt;Verifiable Credentials&lt;br/&gt;45 min]\n    P2 --&gt; P3[Phase 3&lt;br/&gt;Protocol Integration&lt;br/&gt;60 min]\n    P3 --&gt; P4[Phase 4&lt;br/&gt;Real-World Apps&lt;br/&gt;90 min]\n\n    P1 --- O1[Option 1: Core SD-JWT]\n    P1 --- O2[Option 2: JSON Serialization]\n    P1 --- O3[Option 3: Security Features]\n\n    P2 --- O4[Option 4: Verifiable Credentials]\n    P2 --- O5[Option 5: Status Lists]\n\n    P3 --- O6[Option 6: OpenID4VCI]\n    P3 --- O7[Option 7: OpenID4VP]\n    P3 --- O9[Option 9: Presentation Exchange]\n\n    P4 --- OC[Option C: Real-World Use Cases]\n    P4 --- OF[Option F: Financial Co-Pilot AI]\n\n    style P1 fill:#52b788,color:#fff\n    style P2 fill:#40916c,color:#fff\n    style P3 fill:#2d6a4f,color:#fff\n    style P4 fill:#1b4332,color:#fff</code></pre>"},{"location":"getting-started/running-the-samples/#phase-1-core-concepts-30-minutes","title":"Phase 1: Core Concepts (30 minutes)","text":"<p>Goal: Understand selective disclosure and basic SD-JWT operations</p> <ol> <li>Core SD-JWT Example (Option 1)</li> <li>Learn selective disclosure basics</li> <li>See key binding in action</li> <li> <p>Understand presentation creation</p> </li> <li> <p>JSON Serialization Example (Option 2)</p> </li> <li>Explore alternative formats beyond compact JWT</li> <li>See Flattened and General JSON serialization</li> <li> <p>Practice round-trip conversions</p> </li> <li> <p>Security Features Example (Option 3)</p> </li> <li>Understand cryptographic protections</li> <li>See attack prevention in practice</li> <li>Learn privacy protection patterns</li> </ol> <p>Key Takeaways:</p> <ul> <li>How selective disclosure protects privacy</li> <li>Why cryptographic verification matters</li> <li>When to use different serialization formats</li> </ul>"},{"location":"getting-started/running-the-samples/#phase-2-verifiable-credentials-45-minutes","title":"Phase 2: Verifiable Credentials (45 minutes)","text":"<p>Goal: Apply SD-JWT to real-world credential scenarios</p> <ol> <li>Verifiable Credentials Example (Option 4)</li> <li>See industry-standard credential formats</li> <li>Learn VC-specific validation</li> <li> <p>Understand different credential types (medical, education, employment)</p> </li> <li> <p>Status Lists Example (Option 5)</p> </li> <li>Master revocation and suspension</li> <li>Understand multi-bit status types</li> <li>See high-performance status checking</li> </ol> <p>Key Takeaways:</p> <ul> <li>How to structure verifiable credentials</li> <li>Why status management is crucial</li> <li>Performance considerations for scale</li> </ul>"},{"location":"getting-started/running-the-samples/#phase-3-protocol-integration-60-minutes","title":"Phase 3: Protocol Integration (60 minutes)","text":"<p>Goal: Integrate with OpenID standards and modern protocols</p> <ol> <li>OpenID4VCI Example (Option 6)</li> <li>Learn standardized credential issuance</li> <li>See pre-authorized and authorization code flows</li> <li> <p>Practice batch and deferred issuance</p> </li> <li> <p>OpenID4VP Example (Option 7)</p> </li> <li>Master presentation request/response flows</li> <li>Implement cross-device verification</li> <li> <p>Handle complex presentation requirements</p> </li> <li> <p>Presentation Exchange Example (Option 9)</p> </li> <li>Use intelligent credential selection</li> <li>Implement complex constraint matching</li> <li>Optimize for multiple credentials</li> </ol> <p>Key Takeaways:</p> <ul> <li>How OpenID protocols enhance interoperability</li> <li>Why presentation exchange improves user experience</li> <li>When to use different flow types</li> </ul>"},{"location":"getting-started/running-the-samples/#phase-4-real-world-applications-90-minutes","title":"Phase 4: Real-World Applications (90 minutes)","text":"<p>Goal: Build complete end-to-end scenarios</p> <ol> <li>Real-World Use Cases (Option C)</li> <li>See complete industry workflows</li> <li>Practice multi-issuer scenarios</li> <li> <p>Handle complex verification requirements</p> </li> <li> <p>Financial Co-Pilot (Option F)</p> <ul> <li>Experience AI-powered privacy preservation</li> <li>Learn progressive disclosure patterns</li> <li>Understand session-based context management</li> </ul> </li> </ol> <p>Key Takeaways:</p> <ul> <li>How to design complete credential ecosystems</li> <li>Why privacy-preserving AI is revolutionary</li> <li>When to apply different architectural patterns</li> </ul>"},{"location":"getting-started/running-the-samples/#detailed-setup-instructions","title":"Detailed Setup Instructions","text":""},{"location":"getting-started/running-the-samples/#environment-configuration","title":"Environment Configuration","text":""},{"location":"getting-started/running-the-samples/#windows","title":"Windows","text":"<pre><code># Verify .NET installation\ndotnet --version\n\n# Set environment variables (optional, for AI features)\n$env:OPENAI_API_KEY = \"your-api-key\"\n$env:OPENAI_MODEL = \"gpt-4-turbo\"\n\n# Run samples\ncd samples\\SdJwt.Net.Samples\ndotnet run\n</code></pre>"},{"location":"getting-started/running-the-samples/#linuxmacos","title":"Linux/macOS","text":"<pre><code># Verify .NET installation\ndotnet --version\n\n# Set environment variables (optional, for AI features)\nexport OPENAI_API_KEY=\"your-api-key\"\nexport OPENAI_MODEL=\"gpt-4-turbo\"\n\n# Run samples\ncd samples/SdJwt.Net.Samples\ndotnet run\n</code></pre>"},{"location":"getting-started/running-the-samples/#docker-optional","title":"Docker (Optional)","text":"<pre><code># Build container\ndocker build -t sdjwt-samples .\n\n# Run with environment variables\ndocker run -e OPENAI_API_KEY=\"your-key\" sdjwt-samples\n</code></pre>"},{"location":"getting-started/running-the-samples/#ide-setup","title":"IDE Setup","text":""},{"location":"getting-started/running-the-samples/#visual-studio-2022","title":"Visual Studio 2022","text":"<ol> <li>Open <code>sd-jwt-dotnet.sln</code></li> <li>Set <code>SdJwt.Net.Samples</code> as startup project</li> <li>Press F5 or Ctrl+F5 to run</li> <li>Set environment variables in project properties (optional)</li> </ol>"},{"location":"getting-started/running-the-samples/#vs-code","title":"VS Code","text":"<ol> <li>Open the <code>sd-jwt-dotnet</code> folder</li> <li>Install C# extension</li> <li>Open terminal: <code>cd samples/SdJwt.Net.Samples</code></li> <li>Run: <code>dotnet run</code></li> <li>Set environment variables in <code>.vscode/launch.json</code> (optional)</li> </ol>"},{"location":"getting-started/running-the-samples/#jetbrains-rider","title":"JetBrains Rider","text":"<ol> <li>Open <code>sd-jwt-dotnet.sln</code></li> <li>Set run configuration for <code>SdJwt.Net.Samples</code></li> <li>Configure environment variables in run settings (optional)</li> <li>Click the run button</li> </ol>"},{"location":"getting-started/running-the-samples/#ai-integration-setup-updated-2025","title":"AI Integration Setup (Updated 2025)","text":"<p>For the Financial Co-Pilot scenario with real AI responses:</p> <ul> <li>OpenAI API Key: Get from OpenAI Platform</li> <li>Recommended Models:</li> <li><code>gpt-5</code> (Latest production model for 2025)</li> <li><code>gpt-4o</code> (Balanced cost/performance)</li> <li><code>o1-preview</code> (Advanced reasoning for complex financial scenarios)</li> <li>Azure OpenAI (Enterprise): Azure subscription with OpenAI service</li> <li>Cost Estimation: ~$0.01-0.05 per conversation turn with current models</li> </ul>"},{"location":"getting-started/running-the-samples/#azure-openai-configuration-alternative","title":"Azure OpenAI Configuration (Alternative)","text":"<pre><code># Azure OpenAI endpoint\nexport AZURE_OPENAI_ENDPOINT=\"https://your-resource.openai.azure.com/\"\n\n# Your Azure API key\nexport OPENAI_API_KEY=\"your-azure-api-key\"\n\n# Deployment name (not model name in Azure)\nexport OPENAI_MODEL=\"your-gpt4-deployment\"\n</code></pre>"},{"location":"getting-started/running-the-samples/#no-ai-key-no-problem","title":"No AI Key? No Problem","text":"<p>The Financial Co-Pilot automatically falls back to high-quality simulated responses that demonstrate all the privacy-preserving patterns without requiring an API key.</p>"},{"location":"getting-started/running-the-samples/#understanding-the-output","title":"Understanding the Output","text":""},{"location":"getting-started/running-the-samples/#what-youll-see","title":"What You'll See","text":""},{"location":"getting-started/running-the-samples/#successful-credential-creation","title":"Successful Credential Creation","text":"<pre><code>Creating SD-JWT credential...\n   Issuer: https://university.example.edu\n   Subject: did:example:student123\n   Claims: name, degree, graduation_date, gpa\n   Selective Disclosure: degree, graduation_date (revealed), name, gpa (hidden)\n   Key Binding: Enabled\n Credential created successfully\n</code></pre>"},{"location":"getting-started/running-the-samples/#presentation-verification","title":"Presentation Verification","text":"<pre><code>Verifying presentation...\n   Signature validation:  PASSED\n   Key binding validation:  PASSED  \n   Selective disclosure validation:  PASSED\n   Disclosed claims: degree=Bachelor of Science, graduation_date=2024-06-15\n   Hidden claims: name, gpa (not disclosed)\n Verification successful\n</code></pre>"},{"location":"getting-started/running-the-samples/#ai-powered-advice-financial-co-pilot","title":"AI-Powered Advice (Financial Co-Pilot)","text":"<pre><code>INTENT ROUTER: Analyzing query...\n     Detected INTENT: CONTRIBUTION_STRATEGY\n     Required fields: account_balance, cap_remaining\n\nORCHESTRATOR: Requesting Verifiable Presentation...\nWALLET: Creating selective presentation...\n     Presenting data:\n       - account_balance: 150000\n       - cap_remaining: 10000\n     Protected: TFN, full name, address\n\nVERIFIER: Validating presentation...\n     Cryptographic verification successful\n     Key binding confirmed\n     Issuer signatures valid\n\nAI REASONING ENGINE: Processing query...\n     ADVICE: Based on your current balance of $150,000 and remaining contribution cap of $10,000, \n     salary sacrificing would provide significant tax benefits. You're currently in the 32.5% tax bracket, \n     so maximizing your contribution cap could save approximately $3,250 in taxes annually...\n</code></pre>"},{"location":"getting-started/running-the-samples/#common-output-patterns","title":"Common Output Patterns","text":""},{"location":"getting-started/running-the-samples/#success-indicators","title":"Success Indicators","text":"<ul> <li>PASSED: Operation completed successfully</li> <li>Valid: Data integrity confirmed</li> <li>Verified: Cryptographic validation successful</li> <li>Generated: AI advice created</li> <li>Created: Credential or presentation generated</li> </ul>"},{"location":"getting-started/running-the-samples/#information-displays","title":"Information Displays","text":"<ul> <li>Claims Listed: What data is available</li> <li>Disclosed Fields: What data is being shared</li> <li>Protected Fields: What data remains private</li> <li>Performance Metrics: Timing information</li> <li>Security Checks: Validation results</li> </ul>"},{"location":"getting-started/running-the-samples/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/running-the-samples/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/running-the-samples/#build-errors","title":"Build Errors","text":"<pre><code># Clear build artifacts\ndotnet clean\n\n# Restore packages\ndotnet restore\n\n# Build with detailed output\ndotnet build --verbosity detailed\n</code></pre>"},{"location":"getting-started/running-the-samples/#runtime-errors","title":"Runtime Errors","text":"<pre><code># Check .NET version\ndotnet --version\n\n# Ensure you're in the correct directory\npwd # Should show: .../sd-jwt-dotnet/samples/SdJwt.Net.Samples\n\n# Run with detailed error information\ndotnet run --verbosity detailed\n</code></pre>"},{"location":"getting-started/running-the-samples/#openai-api-issues","title":"OpenAI API Issues","text":"<pre><code># Check API key format\necho $OPENAI_API_KEY | head -c 20  # Should start with \"sk-\"\n\n# Test API connectivity (optional)\ncurl -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  https://api.openai.com/v1/models\n\n# Run without AI (uses simulation)\nunset OPENAI_API_KEY\ndotnet run\n</code></pre>"},{"location":"getting-started/running-the-samples/#performance-issues","title":"Performance Issues","text":"<pre><code># Run in Release mode for better performance\ndotnet run --configuration Release\n\n# Check available memory\n# Windows: Get-ComputerInfo | select TotalPhysicalMemory\n# Linux/Mac: free -h\n</code></pre>"},{"location":"getting-started/running-the-samples/#getting-help","title":"Getting Help","text":"<ol> <li>Check Documentation: Read the specific example documentation in <code>docs/samples/examples/</code></li> <li>Review Code: Examine the source code in <code>samples/SdJwt.Net.Samples/Examples/</code></li> <li>Run Tests: Execute unit tests with <code>dotnet test</code></li> <li>Create Issues: Report problems on GitHub</li> <li>Community Support: Join discussions in project forums</li> </ol>"},{"location":"guides/establishing-trust/","title":"How to Establish Trust with OpenID Federation","text":"<p>This guide demonstrates how to configure and use the <code>SdJwt.Net.OidFederation</code> package to implement scalable, automated trust infrastructure.</p> <p>In a small deployment, a Verifier can manually hardcode a list of trusted Issuers (e.g., \"I only trust credentials signed by <code>https://university.example.edu</code> using Key A\"). But in a Sovereign or global ecosystem (like the European Digital Identity Wallet), manual lists are impossible to maintain.</p> <p>OpenID Federation 1.0 solves this by creating \"Trust Chains\" mimicking the DNS or X.509 certificate systems, where intermediate authorities vouch for leaf entities.</p>"},{"location":"guides/establishing-trust/#prerequisites","title":"Prerequisites","text":"<p>Ensure your project references the necessary NuGet packages:</p> <pre><code>dotnet add package SdJwt.Net.OidFederation\n</code></pre>"},{"location":"guides/establishing-trust/#1-configure-federation-the-verifier","title":"1. Configure Federation (The Verifier)","text":"<p>Verifiers need to know which Root Authorities (Trust Anchors) they inherently trust. When a Verifier receives a credential from an unknown Issuer (e.g., a small rural bank), the Verifier will use Federation to see if that bank is endorsed by a trusted Authority (e.g., the National Central Bank).</p>"},{"location":"guides/establishing-trust/#setup-the-federation-client","title":"Setup the Federation Client","text":"<p>In your Verifier's <code>Program.cs</code>:</p> <pre><code>using SdJwt.Net.OidFederation;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddOpenIdFederation(options =&gt;\n{\n    // Your own Entity ID\n    options.EntityId = \"https://verifier.example.com\";\n\n    // The Root Authorities you trust unconditionally\n    options.TrustAnchors = new[]\n    {\n        \"https://financial-federation.gov\", // National Financial Authority\n        \"https://trust.eudi.europa.eu\"      // EU Trust Anchor\n    };\n\n    // Automatically publish your own metadata\n    options.FederationEndpoint = \"/.well-known/openid_federation\";\n});\n\nvar app = builder.Build();\n</code></pre>"},{"location":"guides/establishing-trust/#resolving-a-trust-chain","title":"Resolving a Trust Chain","text":"<p>When a Wallet presents a credential, it provides the Issuer's unique ID (usually their web address). Your Verifier must now dynamically resolve a Trust Chain to that Issuer to fetch their authentic public keys.</p> <pre><code>app.MapPost(\"/verify-login\", async (\n    PresentationResponse response, \n    ISdJwtVerifierService verifier,\n    IFederationService federation) =&gt;\n{\n    // The presentation claims it was issued by this bank\n    string issuerId = \"https://small-rural-bank.com\";\n\n    // 1. Resolve the Trust Chain!\n    // The FederationService automatically walks the tree backwards:\n    // small-rural-bank -&gt; Regional Authority -&gt; National Financial Authority\n    var trustChain = await federation.ResolveTrustChainAsync(issuerId);\n\n    if (!trustChain.IsValid)\n    {\n        // The bank is not trusted by any of our configured Trust Anchors!\n        return Results.Unauthorized($\"Untrusted Issuer: {trustChain.ErrorMessage}\");\n    }\n\n    // 2. Crucially, the Trust Chain provides the *verified* metadata for the Issuer,\n    // including their authentic Public Keys (JWKS).\n    var verifiedMetadata = trustChain.LeafEntity.Metadata;\n    var authenticPublicKeys = verifiedMetadata.Jwks;\n\n    // 3. Now verify the SD-JWT signature using the trusted keys\n    var sdJwtResult = await verifier.VerifyPresentationAsync(response, authenticPublicKeys);\n\n    if (sdJwtResult.IsValid)\n    {\n        return Results.Ok(\"User authenticated successfully.\");\n    }\n});\n</code></pre> <p>Note: If you are using <code>SdJwt.Net.HAIP</code>, this trust chain resolution happens entirely automatically behind the scenes!</p>"},{"location":"guides/establishing-trust/#2-participating-in-a-federation-the-issuer","title":"2. Participating in a Federation (The Issuer)","text":"<p>As an Issuer, you want Verifiers to trust you. To achieve this, you publish an Entity Statement (a signed JWT) at your <code>/.well-known/openid_federation</code> endpoint. This statement declares who you are, what your public keys are, and points to the Authorities that vouch for you.</p>"},{"location":"guides/establishing-trust/#setup-the-federation-endpoint","title":"Setup the Federation Endpoint","text":"<p>In your Issuer's <code>Program.cs</code>:</p> <pre><code>builder.Services.AddOpenIdFederation(options =&gt;\n{\n    options.EntityId = \"https://small-rural-bank.com\";\n\n    // The private key used to sign your own Entity Statement\n    options.SigningKey = myFederationKey;\n\n    // Declare the Authorities you intend to be subordinate to\n    options.AuthorityHints = new[]\n    {\n        \"https://regional-financial-authority.gov\"\n    };\n\n    options.FederationEndpoint = \"/.well-known/openid_federation\";\n});\n</code></pre>"},{"location":"guides/establishing-trust/#automatic-endpoint-publishing","title":"Automatic Endpoint Publishing","text":"<p>The <code>SdJwt.Net.OidFederation</code> package automatically maps the required <code>.well-known</code> endpoints.</p> <pre><code>var app = builder.Build();\n\n// Automatically exposes GET /.well-known/openid_federation\napp.MapOpenIdFederationEndpoints(); \n</code></pre> <p>When a Verifier's server hits <code>GET https://small-rural-bank.com/.well-known/openid_federation</code>, the package will dynamically generate, sign, and return your Entity Statement. The Verifier will then follow the <code>AuthorityHints</code> URL to ask the <code>regional-financial-authority.gov</code> if they have a signed record vouching for your bank, continuing up the chain until it hits a Trust Anchor.</p>"},{"location":"guides/issuing-credentials/","title":"How to Issue Verifiable Credentials","text":"<p>This guide demonstrates how to configure an Issuer application to generate and issue W3C-compliant Verifiable Credentials (VCs) backed by SD-JWT.</p>"},{"location":"guides/issuing-credentials/#prerequisites","title":"Prerequisites","text":"<p>Ensure your project references the necessary NuGet packages:</p> <pre><code>dotnet add package SdJwt.Net.Oid4Vci\ndotnet add package SdJwt.Net.Vc\ndotnet add package SdJwt.Net.HAIP\n</code></pre>"},{"location":"guides/issuing-credentials/#1-configure-the-issuer-service","title":"1. Configure the Issuer Service","text":"<p>First, register the Issuer service in your Dependency Injection container (<code>Program.cs</code> or <code>Startup.cs</code>). This requires setting up your cryptographic signing keys and defining the credential types your service supports.</p> <pre><code>using SdJwt.Net.Oid4Vci;\nusing SdJwt.Net.HAIP;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Security.Cryptography;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Generate or load your private signing key (e.g., from Azure Key Vault)\nvar ecdsa = ECDsa.Create(ECCurve.NamedCurves.nistP256);\nvar issuerSigningKey = new ECDsaSecurityKey(ecdsa);\n\nbuilder.Services.AddSdJwtIssuer(options =&gt;\n{\n    options.IssuerUrl = \"https://issuer.example.com\";\n    options.SigningKey = issuerSigningKey;\n\n    // Define the JSON schema types this issuer supports\n    options.SupportedCredentialTypes = new[]\n    {\n        \"UniversityDegreeCredential\",\n        \"EmployeeIdCredential\"\n    };\n\n    // We are issuing the 'vc+sd-jwt' format defined in OpenID4VCI\n    options.SupportedFormats = new[] { \"vc+sd-jwt\" };\n\n    // Apply HAIP Level 2 Security Policy (e.g., forces DPoP, strictly ES384+)\n    options.UseHaipProfile(HaipLevel.Level2_VeryHigh);\n});\n\nvar app = builder.Build();\n</code></pre>"},{"location":"guides/issuing-credentials/#2-issue-a-credential","title":"2. Issue a Credential","text":"<p>Once OID4VCI handles the OAuth 2.0 component (e.g., the wallet exchanging an authorization code for an access token), your business logic needs to build the actual credential payload.</p> <p>Use the <code>VerifiableCredentialBuilder</code> to construct the W3C payload, explicitly deciding which claims are plain-text and which are <code>SelectiveDisclosure</code> (hidden behind a salt/hash).</p> <pre><code>using SdJwt.Net.Vc;\n\napp.MapPost(\"/issue-degree\", async (\n    CredentialRequest request, \n    ISdJwtIssuerService issuer) =&gt;\n{\n    // 1. Build the W3C Verifiable Credential Payload\n    var vcBuilder = new VerifiableCredentialBuilder()\n        .WithType(\"UniversityDegreeCredential\")\n        .WithIssuer(\"https://issuer.example.com\")\n        .WithSubject($\"did:example:student:{request.UserId}\")\n        .WithIssuanceDate(DateTimeOffset.UtcNow)\n        .WithExpirationDate(DateTimeOffset.UtcNow.AddYears(5))\n\n        // Public information (visible to any verifier)\n        .WithCredentialSubject(\"degreeName\", \"Bachelor of Science in Computer Science\")\n        .WithCredentialSubject(\"university\", \"Example University\")\n\n        // Private information (Holder must explicitly consent to reveal these)\n        .WithSelectiveCredentialSubject(\"gpa\", \"3.8\")\n        .WithSelectiveCredentialSubject(\"graduationDate\", \"2023-05-15\")\n        .WithSelectiveCredentialSubject(\"honors\", \"Summa Cum Laude\");\n\n    // 2. The ISdJwtIssuerService handles the complex SD-JWT hashing and signing logic automatically\n    // It also enforces the configured HAIP policy.\n    var credentialResult = await issuer.CreateCredentialAsync(vcBuilder);\n\n    // 3. Return the standard OID4VCI response to the wallet\n    return Results.Ok(new \n    {\n        credential = credentialResult.SdJwt, // The massive {JWT}~{disc1}~{disc2} string\n        format = \"vc+sd-jwt\"\n    });\n});\n</code></pre>"},{"location":"guides/issuing-credentials/#what-happens-under-the-hood","title":"What happens under the hood?","text":"<p>When <code>issuer.CreateCredentialAsync()</code> runs:</p> <ol> <li>HAIP Validation: HAIP intercepts the call to ensure your <code>issuerSigningKey</code> meets the requirements for <code>Level2_VeryHigh</code> (e.g., throwing an error if you accidentally passed in an insecure RSA 1024-bit key).</li> <li>Salting &amp; Hashing: For <code>gpa</code>, <code>graduationDate</code>, and <code>honors</code>, the <code>SdJwt.Net</code> core generates high-entropy salts, creates disclosure strings, hashes them via SHA-256, and places the hashes into the JWT's <code>_sd</code> array.</li> <li>Decoys: Decoy hashes are injected to prevent observers from guessing how many claims the user has.</li> <li>Signing: The core JWT is signed using your ECDSA key.</li> </ol>"},{"location":"guides/issuing-credentials/#next-steps","title":"Next Steps","text":"<p>Now that the wallet holds the credential, learn how a Relying Party verifies it in the Verifying Presentations Guide.</p>"},{"location":"guides/managing-revocation/","title":"How to Manage Credential Revocation","text":"<p>This guide demonstrates how to configure and use the <code>SdJwt.Net.StatusList</code> package to implement privacy-preserving credential revocation.</p> <p>Unlike traditional JWTs, Verifiable Credentials (VCs) are often long-lived and held independently in user wallets. If a driver's license is suspended, the Issuer cannot simply \"delete\" the credential from the user's phone.</p> <p>To solve this, Issuers publish heavily compressed Status Lists (bitstrings) describing the current state (Valid, Revoked, Suspended) of millions of credentials. Verifiers download these lists to check a credential's status during presentation.</p>"},{"location":"guides/managing-revocation/#prerequisites","title":"Prerequisites","text":"<p>Ensure your project references the necessary NuGet packages:</p> <pre><code>dotnet add package SdJwt.Net.StatusList\ndotnet add package SdJwt.Net.Oid4Vci\n</code></pre>"},{"location":"guides/managing-revocation/#1-configure-the-status-list-service-the-issuer","title":"1. Configure the Status List Service (The Issuer)","text":"<p>The Status List Service handles generating and hosting the compressed bitstrings. We recommend hosting these files statically on a CDN for maximum performance and privacy (Verifiers shouldn't have to ping your API for every single user login, as this compromises the user's privacy).</p> <p>In your <code>Program.cs</code>:</p> <pre><code>using SdJwt.Net.StatusList;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure the Status List Service\nbuilder.Services.AddSdJwtStatusList(options =&gt;\n{\n    // The base URL where your Status Lists will be hosted\n    options.BaseUrl = \"https://status.example.com\";\n\n    // The size of the bitfield (e.g., 131,072 entries)\n    options.StatusListSize = 131072;\n\n    // How often Verifiers should fetch a new list\n    options.RefreshInterval = TimeSpan.FromHours(1);\n});\n\nvar app = builder.Build();\n</code></pre>"},{"location":"guides/managing-revocation/#2-issue-a-credential-with-status-the-issuer","title":"2. Issue a Credential with Status (The Issuer)","text":"<p>When issuing a credential, you must bind it to a specific index in a specific Status List.</p> <pre><code>app.MapPost(\"/issue-employee-id\", async (\n    CredentialRequest request, \n    ISdJwtIssuerService issuer,\n    ISdJwtStatusListService statusList) =&gt;\n{\n    var credentialBuilder = new VerifiableCredentialBuilder()\n        // ... (standard VC configuration) ...\n        .WithType(\"EmployeeIdCredential\");\n\n    // 1. Ask the StatusList Service for a new, unused index\n    // This reserves the index for this specific credential\n    var statusEntry = await statusList.AddCredentialAsync(request.UserId);\n\n    // 2. Add the Status List Entry claim to the credential payload\n    // This tells future Verifiers exactly where to look!\n    credentialBuilder.WithStatusListEntry(statusEntry);\n\n    var credential = await issuer.CreateCredentialAsync(credentialBuilder);\n\n    return Results.Ok(new { credential = credential.SdJwt });\n});\n</code></pre> <p>The VC now contains a <code>status_list</code> object indicating its URL and index.</p>"},{"location":"guides/managing-revocation/#3-revoke-a-credential-the-issuer","title":"3. Revoke a Credential (The Issuer)","text":"<p>When an employee leaves the company, you must revoke their credential.</p> <pre><code>app.MapPost(\"/revoke-employee\", async (\n    string userId, \n    ISdJwtStatusListService statusList) =&gt;\n{\n    // Revoke the credential associated with this internal User ID\n    // This updates the bitfield in the database\n    await statusList.RevokeCredentialAsync(userId, reason: \"Employee departure\");\n\n    // Force a rebuild of the compressed bitstring for the CDN\n    await statusList.PublishStatusListsAsync();\n\n    return Results.Ok();\n});\n</code></pre> <p>The <code>SdJwt.Net.StatusList</code> package handles the complex compression and encoding natively. The <code>PublishStatusListsAsync()</code> method outputs a JSON file containing the Base64-encoded ZLIB-compressed bitstring.</p>"},{"location":"guides/managing-revocation/#4-check-credential-status-the-verifier","title":"4. Check Credential Status (The Verifier)","text":"<p>When a Verifier receives an SD-JWT Presentation, they must check if the credential has been revoked.</p> <p>Because <code>SdJwt.Net.Oid4Vp</code> and <code>SdJwt.Net.HAIP</code> integrate seamlessly with the Status List package, this check occurs automatically during verification if the <code>StatusListService</code> is registered in the Verifier's Dependency Injection container.</p> <pre><code>// In the Verifier's Program.cs\nbuilder.Services.AddSdJwtVerifier(options =&gt; { /* ... */ });\n\n// Tell the Verifier how to handle Status Lists\nbuilder.Services.AddSdJwtStatusListClient(options =&gt;\n{\n    // Use Redis to aggressively cache Status Lists so we aren't\n    // hammering the Issuer's CDN on every login\n    options.UseDistributedCache();\n});\n</code></pre> <p>When you call <code>verifier.VerifyPresentationAsync(response)</code>, the Verifier will:</p> <ol> <li>Parse the <code>status_list</code> object from the presented SD-JWT.</li> <li>Check if it already has an unexpired copy of that Status List URL in its cache.</li> <li>If not, it fetches the compressed bitstring, decompresses it, and parses the bitfield.</li> <li>It checks the specific index for the credential.</li> <li>If the bit indicates <code>Revoked</code> or <code>Suspended</code>, the verification will fail with an error!</li> </ol> <pre><code>var sdJwtResult = await verifier.VerifyPresentationAsync(response);\n\nif (!sdJwtResult.IsValid)\n{\n    if (sdJwtResult.ErrorMessage.Contains(\"Revoked\")) \n    {\n        return Results.Unauthorized(\"User credential has been revoked.\");\n    }\n}\n</code></pre>"},{"location":"guides/verifying-presentations/","title":"How to Verify Presentations","text":"<p>This guide demonstrates how to configure a Relying Party (Verifier) to request, receive, and securely verify an SD-JWT Verifiable Presentation from a User's Wallet.</p>"},{"location":"guides/verifying-presentations/#prerequisites","title":"Prerequisites","text":"<p>Ensure your project references the necessary NuGet packages:</p> <pre><code>dotnet add package SdJwt.Net.Oid4Vp\ndotnet add package SdJwt.Net.PresentationExchange\ndotnet add package SdJwt.Net.HAIP\n</code></pre>"},{"location":"guides/verifying-presentations/#1-configure-the-verifier-service","title":"1. Configure the Verifier Service","text":"<p>Register the Verifier service in your Dependency Injection container.</p> <pre><code>using SdJwt.Net.Oid4Vp;\nusing SdJwt.Net.HAIP;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddSdJwtVerifier(options =&gt;\n{\n    options.VerifierUrl = \"https://verifier.example.com\";\n    options.SupportedVpFormats = new[] { \"vc+sd-jwt\" };\n\n    // Enforce that wallets MUST submit DIF Presentation Exchange definitions\n    options.RequiredPresentationDefinition = true;\n\n    // Apply HAIP Level 2 Security Policy (Forces Key Binding validation)\n    options.UseHaipProfile(HaipLevel.Level2_VeryHigh);\n});\n\nvar app = builder.Build();\n</code></pre>"},{"location":"guides/verifying-presentations/#2-request-data-presentation-exchange","title":"2. Request Data (Presentation Exchange)","text":"<p>When a user clicks \"Login\" or \"Verify Age\" on your site, you must formulate a request telling their wallet exactly what data you need. We use the DIF Presentation Exchange v2.0 format for this.</p> <pre><code>using SdJwt.Net.Oid4Vp;\n\napp.MapPost(\"/request-verification\", async (ISdJwtVerifierService verifier) =&gt;\n{\n    // Define precisely what you need from the user's wallet\n    var definition = new PresentationDefinition\n    {\n        Id = Guid.NewGuid().ToString(),\n        InputDescriptors = new[]\n        {\n            new InputDescriptor\n            {\n                Id = \"university_degree_requirement\",\n                Constraints = new Constraints\n                {\n                    Fields = new[]\n                    {\n                        // 1. Must be a University Degree\n                        new Field\n                        {\n                            Path = new[] { \"$.vc.type\" },\n                            Filter = new { contains = new { @const = \"UniversityDegreeCredential\" } }\n                        },\n                        // 2. We specifically require them to reveal their GPA, and it must be &gt;= 3.0\n                        new Field\n                        {\n                            Path = new[] { \"$.vc.credentialSubject.gpa\" },\n                            Filter = new { type = \"number\", minimum = 3.0 }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    // Generate the OpenID4VP Authorization Request URI\n    var requestUri = await verifier.CreatePresentationRequestAsync(new PresentationRequestOptions\n    {\n        PresentationDefinition = definition,\n        CallbackUri = \"https://verifier.example.com/api/callback\", // Where the wallet POSTs the token\n        Nonce = Guid.NewGuid().ToString() // Crucial for preventing replay attacks!\n    });\n\n    // Return the URI to the frontend to render as a QR code or universal link\n    return Results.Ok(new { request_uri = requestUri });\n});\n</code></pre>"},{"location":"guides/verifying-presentations/#3-verify-the-submission","title":"3. Verify the Submission","text":"<p>Once the user approves the request in their wallet, the wallet will <code>POST</code> the massive SD-JWT string back to your <code>CallbackUri</code>.</p> <pre><code>app.MapPost(\"/api/callback\", async (\n    PresentationResponse response, \n    ISdJwtVerifierService verifier,\n    IPresentationExchangeService peService) =&gt;\n{\n    try \n    {\n        // 1. Core verification: \n        // - Fetches Issuer Public Keys (e.g. via .well-known/jwks.json or Federation)\n        // - Verifies the cryptographic signature\n        // - Hashes the presented disclosures and ensures they match the payload\n        // - Evaluates the Key Binding JWT against the Nonce and Audience\n        var sdJwtResult = await verifier.VerifyPresentationAsync(response);\n\n        if (!sdJwtResult.IsValid)\n        {\n            return Results.BadRequest($\"Invalid Token: {sdJwtResult.ErrorMessage}\");\n        }\n\n        // 2. Logic verification:\n        // - Did the user actually provide the GPA we asked for?\n        // - Was the GPA &gt;= 3.0?\n        var peResult = await peService.EvaluatePresentationAsync(\n            sdJwtResult.Claims, // Only the safely revealed claims!\n            expectedDefinition // Retrieve the definition we saved in Step 2\n        );\n\n        if (!peResult.IsValid)\n        {\n            return Results.BadRequest($\"Presentation Exchange Failed: {peResult.ErrorMessage}\");\n        }\n\n        // 3. Success! Consume the data.\n        var gpa = peResult.MatchedClaims[\"university_degree_requirement\"][\"gpa\"];\n        return Results.Ok($\"Successfully hired candidate with GPA: {gpa}\");\n    }\n    catch (Exception ex)\n    {\n        // Invalid signatures, expired tokens, HAIP policy failures...\n        return Results.Unauthorized(); \n    }\n});\n</code></pre>"},{"location":"guides/verifying-presentations/#security-note-on-trust","title":"Security Note on Trust","text":"<p>In the above code, <code>verifier.VerifyPresentationAsync</code> will inherently trust any issuer that has a valid public key. In production, you must combine this with OpenID Federation Trust Chains to ensure the Issuer is actually authorized to issue University Degrees!</p>"},{"location":"insights/","title":"SD-JWT .NET Insights &amp; Articles","text":"<p>This directory contains thought leadership articles and technical insights about building privacy-preserving systems with Selective Disclosure JSON Web Tokens (SD-JWT).</p>"},{"location":"insights/#articles","title":"Articles","text":""},{"location":"insights/#beyond-redaction-scaling-privacy-preserving-genai-with-sd-jwts","title":"Beyond Redaction: Scaling Privacy-Preserving GenAI with SD-JWTs","text":"<p>Topic: Privacy-preserving AI integration with cryptographic selective disclosure</p> <p>Key Concepts:</p> <ul> <li>Golden Record paradox in financial systems</li> <li>All-or-nothing dilemma in AI context injection</li> <li>SD-JWT as architectural solution</li> <li>OpenID4VCI/VP for standardized workflows</li> <li>Federation &amp; Status List for ecosystem trust</li> <li>HAIP compliance for government-grade systems</li> <li>Multi-turn conversation patterns with progressive disclosure</li> <li>Enhanced 2025 AI landscape (GPT-4o, o1-preview)</li> </ul> <p>Target Audience:</p> <ul> <li>Enterprise architects designing AI systems with regulated data</li> <li>Financial services building personalized AI advisors</li> <li>Government agencies implementing privacy-preserving services</li> <li>Developers implementing SD-JWT in production</li> </ul> <p>Reading Time: 25-30 minutes</p> <p>Key Takeaway: Privacy and personalized AI are not mutually exclusive. By using SD-JWT with cryptographic selective disclosure, you can build AI systems that are context-aware yet privacy-preserving by design.</p>"},{"location":"insights/#automated-compliance-ai-powered-context-aware-data-minimization","title":"Automated Compliance: AI-Powered Context-Aware Data Minimization","text":"<p>Topic: Replacing brittle static rules with AI-driven compliance for presentation definitions.</p> <p>Key Concepts:</p> <ul> <li>Proactive Data Minimization</li> <li>LLM Context-Aware Request Rewriting</li> <li>HAIP Audit Trails for Compliance Proofs</li> </ul>"},{"location":"insights/#quantum-key-distribution-qkd-securing-sovereign-trust","title":"Quantum Key Distribution (QKD): Securing Sovereign Trust","text":"<p>Topic: Protecting Top Secret / Sovereign credentials from \"Harvest Now, Decrypt Later\" quantum threats.</p> <p>Key Concepts:</p> <ul> <li>Quantum Key Distribution for Symmetric Encryption</li> <li>Post-Quantum Cryptography (PQC) Signatures (ML-DSA)</li> <li>Integrating QKD hardware APIs into the <code>.NET</code> ecosystem</li> </ul>"},{"location":"insights/#incident-response-automated-trust-revocation-and-recovery","title":"Incident Response: Automated Trust Revocation and Recovery","text":"<p>Topic: Surviving zero-day issuer compromises with millisecond-scale, automated severing of trust.</p> <p>Key Concepts:</p> <ul> <li>SIEM Integrations with OpenID Federation Webhooks</li> <li>Instant Token Status List updates via CDN</li> <li>Verifier Cache Management and Server-Sent Events</li> </ul>"},{"location":"insights/#research-development","title":"Research &amp; Development","text":"<p>This section evolves as the community explores new patterns and use cases with SD-JWT.</p>"},{"location":"insights/#planned-articles","title":"Planned Articles","text":"<ul> <li>Privacy patterns for healthcare data</li> <li>Multi-issuer credential ecosystems</li> <li>Cross-border credential exchange</li> <li>Blockchain integration with SD-JWT</li> <li>Performance optimization for high-volume scenarios</li> </ul>"},{"location":"insights/#contributing","title":"Contributing","text":"<p>Have an insight or pattern worth sharing?</p> <ol> <li>Write your article in markdown format</li> <li>Include:</li> <li>Clear problem statement</li> <li>Solution architecture (diagrams welcome)</li> <li>Code examples where applicable</li> <li>References to standards and packages</li> <li>Practical implementation guidance</li> <li>Submit a pull request with your article</li> </ol> <p>Articles should be:</p> <ul> <li>Practical: Real problems, real solutions</li> <li>Well-structured: Clear sections with progressive detail</li> <li>Referenced: Link to standards, specs, and code</li> <li>Evergreen: Timeless patterns over trendy techniques</li> </ul>"},{"location":"insights/#related-documentation","title":"Related Documentation","text":"<ul> <li>Samples - Code examples and running demos</li> <li>Developer Guide - Technical reference</li> <li>Architecture Design - System architecture patterns</li> <li>Financial Co-Pilot - Practical AI integration example</li> </ul> <p>Last Updated: February 2026 License: Apache 2.0</p>"},{"location":"insights/ai-financial-co-pilot/","title":"Beyond Redaction: Scaling Privacy-Preserving GenAI with SD-JWTs","text":""},{"location":"insights/ai-financial-co-pilot/#how-selective-disclosure-enables-personalized-ai-without-toxic-privacy-risks","title":"How selective disclosure enables personalized AI without toxic privacy risks","text":"<p>In the race to deploy Generative AI, the \"Hello World\" phase is over. Engineering teams are now tackling the \"Day 2\" reality: how to make these systems useful in highly regulated industries without creating a data privacy nightmare.</p> <p>Consider the Australian Superannuation industry. Members are demanding more than static dashboards; they want personalized, conversational guidance. They want to ask: \"Should I salary sacrifice this year?\"</p> <p>To answer these questions, an LLM needs context. Historically, this meant retrieving a member's \"Golden Record\"a monolithic data structure containing everything from their home address to their beneficiary history. But feeding this entire record into an LLM context window is a non-starter for security and compliance.</p> <p>This article explores a robust architectural pattern we can use to solve this: Selective Disclosure JSON Web Tokens (SD-JWT). By deconstructing the Golden Record and moving from simple redaction to cryptographic selective disclosure, we can build AI agents that are context-aware yet privacy-preserving by design.</p>"},{"location":"insights/ai-financial-co-pilot/#background-the-golden-record-paradox","title":"Background: The \"Golden Record\" Paradox","text":"<p>To understand the security challenge, we first need to look at the data topology of a typical registry system.</p> <p>In legacy architectures, member data is often stored as a tightly coupled, monolithic object. When a backend service requests \"Member Details,\" it receives the entire blob. While efficient for traditional web apps, this structure is toxic for GenAI.</p> <p>To give accurate financial advice, we need to separate the \"Who\" from the \"What.\"</p>"},{"location":"insights/ai-financial-co-pilot/#the-data-coupling-issue","title":"The Data Coupling Issue","text":"<p>We classify member data into two distinct buckets based on their utility to the AI and their risk to the business:</p> Data Class Definition Superannuation Examples Identity PII The \"Who\" (Toxic) Tax File Number (TFN), Full Name, Address, DOB. Leakage here is a reportable breach. Financial State The \"What\" (Useful) Account Balance, Cap Room, Admin Fees. Essential for personalizing the calculation. <p>The Architecture Gap: To answer a question like \"Can I afford to contribute more?\", the AI Agent requires the Financial State. However, because of the Golden Record structure, most APIs force developers to fetch the Identity PII simultaneously. You cannot get the \"Cap Room\" without also getting the \"TFN\".</p>"},{"location":"insights/ai-financial-co-pilot/#the-problem-the-all-or-nothing-dilemma","title":"The Problem: The \"All-or-Nothing\" Dilemma","text":"<p>When engineers try to bridge this gap, they usually face three bad options:</p> <ol> <li>The \"Full Context\" Injection: Dumping the full profile into the Prompt. This is oversharing by default.</li> <li>User-Driven Input: Asking the user to type their balance. This creates \"garbage in, garbage out\" scenarios where the AI trusts unverified data.</li> <li>Middleware Redaction: Using Regex to strip TFNs. This is fragile; as schemas change, redaction rules break, and there is no cryptographic proof that the remaining data is authentic.</li> </ol>"},{"location":"insights/ai-financial-co-pilot/#the-2025-ai-landscape-challenge","title":"The 2025 AI Landscape Challenge","text":"<p>With the evolution of AI models in 2025:</p> <ul> <li>GPT-4o and o1-preview require more context for optimal performance</li> <li>Larger context windows (128k+ tokens) enable richer conversations</li> <li>Multimodal capabilities increase the scope of potential data exposure</li> <li>Real-time processing demands instant data validation</li> </ul> <p>The privacy challenges have only intensified.</p>"},{"location":"insights/ai-financial-co-pilot/#the-solution-selective-disclosure-sd-jwt","title":"The Solution: Selective Disclosure (SD-JWT)","text":"<p>The industry is coalescing around a new standard to solve this: SD-JWT (IETF RFC 9901).</p> <p>SD-JWT allows us to sign a JSON object but enables the client to reveal only specific fields to a server while maintaining the validity of the original signature.</p> <p>Think of it as a Verified Financial Snapshot. The Registry signs a statement containing all member facts. However, the application layer can selectively reveal only the Financial State, keeping Identity PII cryptographically hidden from the AI.</p>"},{"location":"insights/ai-financial-co-pilot/#architecture-the-verified-snapshot-workflow","title":"Architecture: The \"Verified Snapshot\" Workflow","text":"<p>To implement this, we shift the architecture from a server-centric model to a user-centric model utilizing OpenID4VCI for issuance and OpenID4VP for presentation.</p>"},{"location":"insights/ai-financial-co-pilot/#component-architecture","title":"Component Architecture","text":"<pre><code>graph TB\n    subgraph \"Mobile App (Holder)\"\n        SecureEnc[Secure Enclave&lt;br/&gt;Credential Store]\n        WalletSDK[SdJwt.Net&lt;br/&gt;Wallet SDK]\n    end\n\n    subgraph \"AI Service (Verifier)\"\n        IntentRouter[Intent Router&lt;br/&gt;GPT-4o Classifier]\n        Orchestrator[Orchestrator&lt;br/&gt;Presentation Definitions]\n        AutomatedCompl[AI Compliance Assessor&lt;br/&gt;Context-Aware Rules]\n        VerifEngine[Verification Engine&lt;br/&gt;SdJwt.Net.Oid4Vp]\n        LLMEngine[LLM Reasoning&lt;br/&gt;o1-preview / GPT-4o]\n    end\n\n    subgraph \"Registry / Issuer\"\n        Registry[Source of Truth&lt;br/&gt;Golden Record]\n        IssuerSvc[SD-JWT Issuer&lt;br/&gt;SdJwt.Net.Oid4Vci]\n    end\n\n    subgraph \"Trust Infrastructure\"\n        FedSvc[OpenID Federation&lt;br/&gt;QKD-Secured Anchors]\n        StatusSvc[Token Status List&lt;br/&gt;Revocation CDN]\n        SIEM[SIEM&lt;br/&gt;Incident Response]\n    end\n\n    Registry --&gt; IssuerSvc\n    IssuerSvc --&gt;|SD-JWT vc+sd-jwt| SecureEnc\n    SecureEnc --&gt; WalletSDK\n\n    WalletSDK --&gt;|VP Token selective claims| VerifEngine\n    IntentRouter --&gt;|Intent + required fields| Orchestrator\n    Orchestrator --&gt; AutomatedCompl\n    AutomatedCompl --&gt;|Proactive Data Minimization| WalletSDK\n\n    VerifEngine --&gt;|verified facts| LLMEngine\n    VerifEngine --&gt; FedSvc\n    VerifEngine --&gt; StatusSvc\n    SIEM -.-&gt;|Zero-Day Takedown| FedSvc &amp; StatusSvc\n\n    LLMEngine --&gt;|Personalized Advice| WalletSDK\n\n    style SecureEnc fill:#1b4332,color:#fff\n    style LLMEngine fill:#2d6a4f,color:#fff\n    style FedSvc fill:#40916c,color:#fff\n    style AutomatedCompl fill:#b0891d,color:#fff</code></pre> <pre><code>sequenceDiagram\n    participant Registry as Registry (Source)\n    participant Issuer as Identity Provider\n    participant App as Mobile App (Holder)\n    participant Verifier as AI Service\n    participant Compliance as AI Compliance Assessor\n    participant LLM as GenAI Model\n\n    Note over Registry, App: Step 1: Issuance (OpenID4VCI)\n    App-&gt;&gt;Issuer: Request \"Financial Snapshot\"\n    Issuer-&gt;&gt;Registry: Fetch Golden Record\n    Issuer-&gt;&gt;App: Issue SD-JWT (Salted &amp; Hashed)\n\n    Note over App, Verifier: Step 2: Storage\n    App-&gt;&gt;App: Store Credential in Secure Enclave\n\n    Note over App, LLM: Step 3: AI Interaction\n    App-&gt;&gt;Verifier: \"Should I salary sacrifice?\"\n    Verifier-&gt;&gt;LLM: Classify Intent\n    LLM--&gt;&gt;Verifier: INTENT: CONTRIBUTION_STRATEGY\n\n    Note over Verifier, App: Step 4: Automated Compliance Review\n    Verifier-&gt;&gt;Compliance: Evaluate Request vs GDPR Context\n    Compliance-&gt;&gt;Compliance: Block unnecessary PI / Approve Financials\n    Compliance--&gt;&gt;App: Presentation Request (Validated)\n\n    Note over Verifier, App: Step 5: Selective Presentation\n    App-&gt;&gt;Verifier: Verifiable Presentation (No TFN, No Name)\n\n    Note over Verifier, LLM: Step 6: Verification &amp; Advice\n    Verifier-&gt;&gt;Verifier: Verify Signature, Trust Chain, Status\n    Verifier-&gt;&gt;LLM: Prompt with Verified Context\n    LLM--&gt;&gt;App: Personalized Financial Advice</code></pre>"},{"location":"insights/ai-financial-co-pilot/#step-1-issuance-openid4vci","title":"Step 1: Issuance (OpenID4VCI)","text":""},{"location":"insights/ai-financial-co-pilot/#how-the-app-gets-the-data","title":"How the App gets the data","text":"<p>We don't build custom APIs to fetch these tokens. We use OpenID for Verifiable Credential Issuance (OpenID4VCI 1.0).</p> <ul> <li>The Member logs into the App via standard OIDC (e.g., Auth0/IdentityServer).</li> <li>The App requests a <code>financial_snapshot_credential</code>.</li> <li>The Issuer wraps the Registry data in an SD-JWT, salts the sensitive fields, and delivers it to the App.</li> <li>Why this matters: OpenID4VCI standardizes how wallets and apps negotiate authentication and encryption, ensuring the token is delivered securely to the right device.</li> </ul>"},{"location":"insights/ai-financial-co-pilot/#step-2-storage-the-holder","title":"Step 2: Storage (The Holder)","text":"<p>The Credential is sent to the Mobile App, which stores it in secure storage (iOS Secure Enclave, Android Strongbox). The member's device now holds the \"truth,\" removing the need for a persistent backend session cache.</p>"},{"location":"insights/ai-financial-co-pilot/#step-3-enhanced-intent-classification-automated-compliance","title":"Step 3: Enhanced Intent Classification &amp; Automated Compliance","text":""},{"location":"insights/ai-financial-co-pilot/#how-modern-ai-translates-human-speak-into-protocol-speak-securely","title":"How modern AI translates \"Human Speak\" into \"Protocol Speak\" securely","text":"<p>The AI Service doesn't magically know which fields to fetch, nor can we trust it blindly. We use a three-step process: Intent Classification, Smart Schema Mapping, and Automated Compliance Assessment.</p> <ol> <li> <p>The Enhanced Classifier: When the user asks \"Should I salary sacrifice?\", the orchestrator analyzes the text with improved context understanding.</p> <ul> <li>Output: <code>INTENT: CONTRIBUTION_STRATEGY, REQUIRED_CONTEXT: FINANCIAL_STATE</code></li> </ul> </li> <li> <p>The Smart Mapper: The backend maps this intent to a baseline Presentation Definition (DIF PE v2.1.1).</p> </li> <li> <p>Automated Compliance Assessor (Advanced Use Case): Traditional hardcoded compliance rules are brittle. Before the Presentation Definition is sent to the user, an AI-powered compliance engine (implementing <code>IHaipValidator</code>) intercepts it. It evaluates the request context against strict privacy laws like GDPR Article 5 (Data Minimization).</p> <ul> <li>Example: If the mapped baseline definition includes <code>home_address</code>, the Compliance Assessor determines this is unnecessary for financial extrapolation. It proactively rewrites the Presentation Definition to explicitly block that claim, ensuring the user's wallet is never even prompted to share it. The AI's decision reasoning is immutably logged to the HAIP audit trail.</li> </ul> </li> </ol> <p>The Empowered Handshake: The AI Service sends the compliance-validated Authorization Request to the App:</p> <p>\"I need you to present a valid credential issued by [Fund Name], specifically the fields <code>balance</code> and <code>cap_remaining</code>. Note: <code>home_address</code> access was blocked by the automated compliance engine to protect your privacy.\"</p>"},{"location":"insights/ai-financial-co-pilot/#step-4-progressive-selective-presentation-the-holder","title":"Step 4: Progressive Selective Presentation (The Holder)","text":""},{"location":"insights/ai-financial-co-pilot/#what-actually-gets-sent-across-the-wire","title":"What actually gets sent across the wire","text":"<p>The App receives the request. The user approves, and the SdJwt.Net library generates a response. The App does not send a plain JSON file. It sends a Verifiable Presentation (VP) containing:</p> <ol> <li>The Signed Wrapper: The original signature from the Fund.</li> <li>The Required Disclosures: The specific values the user chose to reveal (e.g., \"$50,000\"), along with the cryptographic \"salt.\"</li> <li>Key Binding (KB-JWT): Proves the presentation came directly from the user's secure enclave.</li> </ol>"},{"location":"insights/ai-financial-co-pilot/#step-5-enhanced-verification-ai-reasoning","title":"Step 5: Enhanced Verification &amp; AI Reasoning","text":"<p>The AI Service receives the presentation and performs cryptographic validation:</p> <ul> <li>Verifies the signature matches the Issuer (The Fund).</li> <li>Hashes the disclosed values to ensure they match the signed digest.</li> <li>Verifies the Trust Chain and Token Status.</li> <li>Feeds the verified numbers into the appropriate advanced LLM model for the final advice.</li> </ul> <p>Model Selection Logic (2025):</p> <pre><code>const selectModel = (intent, contextComplexity, userTier) =&gt; {\n  if (intent === 'COMPLEX_RETIREMENT_PLANNING' &amp;&amp; contextComplexity &gt; 0.8) {\n    return 'o1-preview'; // Advanced reasoning for complex scenarios\n  }\n  if (userTier === 'premium' || contextComplexity &gt; 0.6) {\n    return 'gpt-4o'; // Latest model for premium experience\n  }\n  return 'gpt-4-turbo'; // Balanced cost/performance\n};\n</code></pre>"},{"location":"insights/ai-financial-co-pilot/#advanced-architecture-security-scale-and-zero-day-responses","title":"Advanced Architecture: Security, Scale, and Zero-Day Responses","text":"<p>In a real-world Superannuation ecosystem, two massive operational problems exist: Sovereign Trust (How do we guarantee keys aren't broken by future quantum computers?) and Incident Response (How do we stop stolen credentials instantly?).</p>"},{"location":"insights/ai-financial-co-pilot/#1-quantum-key-distribution-qkd-sovereign-trust-anchors","title":"1. Quantum Key Distribution (QKD) &amp; Sovereign Trust Anchors","text":"<p>The Superannuation industry relies on High-Assurance Identity Profiles (HAIP Level 3). As we look toward the future, these trust frameworks face the existential threat of \"Harvest Now, Decrypt Later\" capabilities of quantum computers against standard ECDSA keys.</p> <ul> <li>Securing Trust Chains: Using the ecosystem's Quantum Key Distribution (QKD) integrations, physical optical hardware distributes symmetric encryption keys between government agencies/hubs using quantum mechanics (interception destroys the state).</li> <li>Post-Quantum Cryptography: The OpenID Federation 1.0 trust anchors\u2014the entity statements managed by authorities like APRA\u2014are signed using NIST-approved post-quantum algorithms (e.g., ML-DSA). When the AI Service verifies the trust chain, it utilizes the <code>SdJwt.Net</code> core extensions to validate quantum-resistant signatures, guaranteeing the trust hierarchy itself cannot be breached by a future quantum adversary.</li> </ul>"},{"location":"insights/ai-financial-co-pilot/#2-incident-response-automated-trust-revocation","title":"2. Incident Response: Automated Trust Revocation","text":"<p>What happens when an issuer's private signing keys are compromised by a rogue insider or a zero-day exploit? Waiting for human operators to revoke certificates leaves the entire AI ecosystem vulnerable to forged data injections.</p> <p>Zero-Day Issuer Compromise Containment:</p> <ul> <li>When a regional banking consortium's intrusion detection (SIEM) flags a key compromise, it fires an automated webhook.</li> <li>Federation Severing (<code>SdJwt.Net.OidFederation</code>): Within milliseconds, the OpenID Federation intermediary authority automatically re-publishes its Entity Statement, explicitly amputating the compromised bank's <code>entity_id</code> from its subordinate list.</li> <li>Sweeping Token Revocation (<code>SdJwt.Net.StatusList</code>): The SIEM simultaneously triggers the Token Status List service to toggle the indices of all active credentials issued by those keys to <code>Revoked</code> (bit=1). This updated, highly-compressed bitstring propagates to the edge CDN instantly.</li> <li>Result: Before an attacker can inject fraudulent data into the AI models, validation attempts are instantly rejected upstream at the Trust Chain or Token Status layer\u2014a self-healing, automated response requiring zero human intervention.</li> </ul>"},{"location":"insights/ai-financial-co-pilot/#deep-dive-handling-multi-turn-conversations-enhanced-2025","title":"Deep Dive: Handling Multi-Turn Conversations (Enhanced 2025)","text":"<p>Members rarely ask one question and stop. A typical session is a chain of evolving context with improved session management:</p> <p>Turn 1: \"Should I salary sacrifice?\" Turn 2: \"Ok. If I add $200 per fortnight, does that change my insurance?\" Turn 3: \"What if I retire at 60 vs 65?\" Turn 4: \"Can you email me a summary?\"</p> <p>In a traditional architecture, the AI backend maintains a growing session state. With SD-JWT, we use Progressive Disclosure with Session Context.</p> <ul> <li>Turn 1: AI requests <code>Balance</code>. App generates VP #1. AI gives advice and maintains minimal session context.</li> <li>Turn 2: AI requests <code>Insurance_Premiums</code>. The AI does not go back to the Registry. It asks the App again. The App generates VP #2 from the same cached Credential.</li> <li>Turn 3: AI requests <code>Age_Bracket</code> for retirement projections. App generates VP #3 with progressive disclosure.</li> <li>Turn 4: AI compiles a Statement of Advice using all verified data points with complete audit trail.</li> </ul>"},{"location":"insights/ai-financial-co-pilot/#security-deep-dive-why-auditors-trust-client-side-data-haip-enhanced","title":"Security Deep Dive: Why Auditors Trust Client-Side Data (HAIP Enhanced)","text":"<p>For an auditor, the \"proof\" is the Verifiable Presentation (VP) with HAIP compliance validation. This provides multiple layers of cryptographic guarantees:</p> <ol> <li>Proof of Origin: The Issuer Signature proves the data came from the Fund with HAIP Level validation.</li> <li>Proof of Integrity: The Salted Hashes prove the values haven't been tampered with.</li> <li>Proof of Possession: Key Binding proves the request came from the user's secure device.</li> <li>Proof of Compliance: HAIP validation ensures enterprise-grade security standards.</li> <li>Proof of Trust: Federation chains validate issuer legitimacy in real-time.</li> </ol>"},{"location":"insights/ai-financial-co-pilot/#conclusion","title":"Conclusion","text":"<p>The transition from AI prototypes to production requires a fundamental shift in how we handle data. We cannot rely on policy documents or fragile redaction code to protect user privacy. We need architectural guarantees.</p> <p>By combining SD-JWT for selective disclosure, OpenID4VCI for standardized issuance, OpenID Federation for ecosystem trust, and HAIP for compliance validation, we can feed GenAI engines the fuel they need without burning down the privacy fence.</p> <p>The 2025 landscape brings enhanced AI capabilities with GPT-4o and o1-preview, but also heightened privacy requirements. The patterns demonstrated in the SdJwt.Net Financial Co-Pilot show that we can have both personalized AI and cryptographic privacy guarantees.</p> <p>The future of AI is not just about larger modelsit's about verifiable, selective, privacy-preserving intelligence.</p>"},{"location":"insights/ai-financial-co-pilot/#see-also","title":"See Also","text":"<ul> <li>SdJwt.Net on GitHub - Complete ecosystem with Financial Co-Pilot</li> <li>IETF RFC 9901 - Selective Disclosure for JWTs</li> <li>OpenID4VCI 1.0 - Credential Issuance Specification</li> <li>OpenID4VP 1.0 - Verifiable Presentations</li> <li>OpenID Federation 1.0 - Trust Ecosystems</li> <li>DIF PE v2.1.1 - Presentation Exchange</li> <li>HAIP 1.0 - High Assurance Interoperability Profile</li> </ul>"},{"location":"insights/automated-compliance/","title":"Automated Compliance: AI-Powered Context-Aware Data Minimization","text":""},{"location":"insights/automated-compliance/#the-problem-brittle-compliance-engines","title":"The Problem: Brittle Compliance Engines","text":"<p>In highly regulated domains\u2014such as healthcare, government services, or cross-border finance\u2014organizations are strictly bound by principles of data minimization (such as GDPR Article 5). A verifier should only request and process the absolute minimum personal identity information (PII) necessary for a specific transaction.</p> <p>Traditional compliance engines have attempted to solve this using static rules engines (like OPA or complex switch statements). However, these rules are notoriously brittle. They struggle to interpret the context and intent behind a data request.</p> <p>For example, a request for a <code>home_address</code> might be fully compliant if a user is applying for a home loan, but a severe privacy violation if a user is simply verifying their age to purchase a restricted product. Hardcoding every possible context for every possible credential claim is an unscalable maintenance nightmare.</p>"},{"location":"insights/automated-compliance/#the-solution-ai-powered-compliance-assessor","title":"The Solution: AI-Powered Compliance Assessor","text":"<p>By combining the cryptographic assurances of SdJwt.Net with the reasoning capabilities of modern Large Language Models (LLMs), we can build an Automated Compliance Assessor.</p> <p>Rather than relying on static rules, this component intercepts a Presentation Definition (the request for data) before it gets to the user's wallet. The LLM evaluates the intent of the request against the legal and policy frameworks it has been trained on (or provided in its system prompt), and proactively strips out unjustified data requests.</p>"},{"location":"insights/automated-compliance/#use-case-context-aware-medical-data-disclosure","title":"Use Case: Context-Aware Medical Data Disclosure","text":"<ol> <li>The Request: A researcher at a pharmaceutical company requests access to a patient's medical Verifiable Credentials (VCs) for an anonymous oncology study.</li> <li>The Default Presentation Definition: The generic healthcare API asks for <code>age</code>, <code>blood_type</code>, <code>current_medications</code>, and <code>home_address</code>.</li> <li>The Interception: Instead of passing this directly to the patient's wallet, the AI Compliance Assessor (implementing <code>IHaipValidator</code> or a similar pipeline step) intercepts the request.</li> <li>The Evaluation: The LLM evaluates the request's context (\"anonymous oncology study\") against GDPR data minimization rules.<ul> <li>LLM Reasoning: <code>age</code> and <code>current_medications</code> are necessary for an oncology study. However, <code>home_address</code> is highly identifying and violates data minimization for an anonymous study.</li> </ul> </li> <li>The Counter-Proposal: The AI automatically rewrites the Presentation Definition, explicitly removing or blocking the <code>home_address</code> claim.</li> <li>The Result: The patient opens their wallet. They are prompted only to share their age and medications. They are never even asked for their address, completely eliminating the user error of over-sharing. The AI\u2019s reasoning is immutably logged to the HAIP audit trail to prove proactive compliance.</li> </ol>"},{"location":"insights/automated-compliance/#implementing-with-sdjwtnet","title":"Implementing with SdJwt.Net","text":"<p>To implement this advanced architecture, you would inject an AI compliance step into your presentation generation or validation pipeline.</p> <pre><code>// Example conceptual pipeline\npublic class AiComplianceValidator : IHaipValidator\n{\n    private readonly IAiService _llmService;\n\n    public AiComplianceValidator(IAiService llmService)\n    {\n        _llmService = llmService;\n    }\n\n    public async Task&lt;ValidationResult&gt; ValidatePresentationRequestAsync(\n        PresentationDefinition request, \n        TransactionContext context)\n    {\n        // 1. Serialize the request and context\n        var promptContext = new {\n            RequestedClaims = request.InputDescriptors.Select(id =&gt; id.Id),\n            Purpose = context.StatedIntent,\n            RegulatoryFramework = \"GDPR Article 5 (Data Minimization)\"\n        };\n\n        // 2. Ask the LLM to evaluate necessity\n        var aiDecision = await _llmService.EvaluateComplianceAsync(promptContext);\n\n        if (!aiDecision.IsCompliant)\n        {\n            // 3. Reject or Rewrite the request based on AI reasoning\n            return ValidationResult.Fail($\"AI Compliance Block: {aiDecision.Reasoning}\");\n        }\n\n        return ValidationResult.Success();\n    }\n}\n</code></pre> <p>By leveraging the <code>SdJwt.Net.PresentationExchange</code> package, the AI modifies the Presentation Definition object in memory before it is ever serialized and sent to the Holder.</p>"},{"location":"insights/automated-compliance/#security-and-auditability","title":"Security and Auditability","text":"<p>A common concern with AI is non-deterministic behavior. To satisfy auditors:</p> <ol> <li>AI as a Filter, Not an Issuer: The AI never creates data or signs credentials. It only reduces the scope of what is requested. Over-blocking leads to a failed transaction (fail-secure), but under-blocking is caught by standard user consent.</li> <li>HAIP Audit Trails: The exact prompt sent to the LLM, the model version, and the output tokens (reasoning) are logged immutably via the HAIP auditing interface <code>IAuditLogger</code>.</li> <li>Human-in-the-Loop Fallback: If the AI flags a request but scores low confidence, the transaction is routed to a human compliance officer queue.</li> </ol>"},{"location":"insights/incident-response/","title":"Incident Response: Automated Trust Revocation and Recovery","text":""},{"location":"insights/incident-response/#the-problem-the-zero-day-compromise","title":"The Problem: The Zero-Day Compromise","text":"<p>In any large-scale digital identity ecosystem, the nightmare scenario is the compromise of an Issuer's private signing keys. This could occur due to a malicious insider, a zero-day exploit against an HSM (Hardware Security Module), or a fundamental failure in a Certification Authority (CA).</p> <p>When keys are compromised, the attacker can instantly begin mass-issuing fraudulent, mathematically valid credentials (e.g., fake \"High-Value Customer\" financial profiles, or forged university degrees).</p> <p>The traditional response is dangerously slow. It relies on human operators noticing the anomaly, manually updating Certificate Revocation Lists (CRLs), or coordinating with partners to update manual blocklists. This creates a \"window of exposure\" that can last hours or days, during which verifiers remain oblivious and continue to accept fraudulent credentials, resulting in massive damage.</p>"},{"location":"insights/incident-response/#the-solution-automated-revocation-architecture","title":"The Solution: Automated Revocation Architecture","text":"<p>To survive a zero-day key compromise, the ecosystem requires an automated, self-healing incident response architecture. When an intrusion is detected, the system must sever trust across the entire network in milliseconds, requiring zero human intervention.</p> <p>This is achieved by tightly integrating the organization's SIEM (Security Information and Event Management) system directly into the identity trust infrastructure\u2014specifically manipulating OpenID Federation trust chains and Token Status Lists.</p>"},{"location":"insights/incident-response/#use-case-zero-day-issuer-containment","title":"Use Case: Zero-Day Issuer Containment","text":"<ol> <li>The Breach: An attacker breaches the perimeter of a regional banking consortium and exfiltrates active ECDSA signing keys. They begin signing fraudulent SD-JWT credentials.</li> <li>Detection: Within seconds, the consortium's SIEM (e.g., Azure Sentinel or Splunk) flags anomalous behavior (e.g., irregular API access patterns to the key vault, or impossible issuance velocity).</li> <li>The Automated Trigger: The SIEM triggers an automated \"Containment Playbook\" webhook.</li> <li>Federation Severing (<code>SdJwt.Net.OidFederation</code>):<ul> <li>The webhook hits the OpenID Federation Intermediary Authority API.</li> <li>Within milliseconds, the intermediary automatically re-publishes its Entity Statement, explicitly amputating the compromised bank's <code>entity_id</code> from its list of valid subordinates.</li> </ul> </li> <li>Sweeping Token Revocation (<code>SdJwt.Net.StatusList</code>):<ul> <li>Simultaneously, the SIEM triggers the localized Token Status List service.</li> <li>The service modifies the highly-compressed bitstring representing credential validity, toggling the indices of all active credentials issued by those compromised keys to <code>Revoked</code> (bit=1). This updated bitstring propagates to the edge CDN instantly.</li> </ul> </li> <li>The Result: Before the attacker can even present the fraudulent SD-JWTs to a relying party, the verifier attempts to resolve the trust chain. The resolution fails instantly at the intermediary level. The attacker is cut off globally.</li> </ol>"},{"location":"insights/incident-response/#implementing-with-sdjwtnet","title":"Implementing with SdJwt.Net","text":"<p>The <code>SdJwt.Net</code> suite provides the necessary hooks to build these automated response pipelines.</p>"},{"location":"insights/incident-response/#federation-webhooks","title":"Federation Webhooks","text":"<p>Configure your <code>SdJwt.Net.OidFederation</code> authority service with dedicated, highly-secured internal endpoints for SIEM integration.</p> <pre><code>[HttpPost(\"api/incident-response/sever-entity\")]\n[Authorize(Roles = \"SIEM_Automation_Engine\")]\npublic async Task&lt;IActionResult&gt; SeverTrustRelationship([FromBody] SeveranceRequest request)\n{\n    // 1. Log the automated incident\n    _logger.LogCritical(\"AUTOMATED CONTAINMENT TRIGGERED for Entity: {EntityId}\", request.TargetEntityId);\n\n    // 2. Remove the entity from the active subordinate list in the database\n    await _federationDb.Subordinates.UpdateStatusAsync(request.TargetEntityId, TrustStatus.Revoked);\n\n    // 3. Force an immediate recalculation and re-signing of the Authority's Entity Statement\n    await _federationEngine.ForceRebuildEntityStatementAsync();\n\n    return Ok(\"Trust severed and Entity Statement republished.\");\n}\n</code></pre>"},{"location":"insights/incident-response/#real-time-status-lists","title":"Real-Time Status Lists","text":"<p>Connect the <code>IStatusListService</code> to quickly toggle mass indices. Because Token Status Lists are highly compressed bitstrings (often gzip compressed over HTTP), updating thousands of indices and pushing them to a CDN takes milliseconds.</p> <pre><code>[HttpPost(\"api/incident-response/mass-revoke\")]\n[Authorize(Roles = \"SIEM_Automation_Engine\")]\npublic async Task&lt;IActionResult&gt; MassRevokeKeys([FromBody] Guid compromisedKeyId)\n{\n    // 1. Identify all active credentials signed by this key\n    var affectedIndices = await _credentialDb.GetIndicesForKeyAsync(compromisedKeyId);\n\n    // 2. Update the status list in memory\n    foreach(var idx in affectedIndices)\n    {\n        _statusListService.UpdateStatus(idx, StatusValue.Revoked);\n    }\n\n    // 3. Publish the new bitstring to the Edge Network (CDN)\n    await _statusListService.PublishToCdnAsync();\n\n    return Ok($\"Revoked {affectedIndices.Count} credentials instantly.\");\n}\n</code></pre>"},{"location":"insights/incident-response/#verifier-cache-management","title":"Verifier Cache Management","text":"<p>To ensure verifiers react quickly, <code>SdJwtVerifier</code> instances should be configured with aggressive cache expiration policies for Federation chains, or utilize Server-Sent Events (SSE) / WebSockets to proactively invalidate local caches when the SIEM fires a major incident alert.</p>"},{"location":"insights/quantum-key-distribution/","title":"Quantum Key Distribution (QKD): Securing Sovereign Trust","text":""},{"location":"insights/quantum-key-distribution/#the-problem-the-quantum-threat-to-identity","title":"The Problem: The Quantum Threat to Identity","text":"<p>High-Assurance Identity Profiles (HAIP Level 3 - Sovereign) are designed for credentials that form the backbone of national infrastructure: Top Secret clearances, diplomatic passports, core central bank infrastructure, and national digital ID wallets. These credentials and their underlying trust chains must remain secure for decades.</p> <p>The cryptographic foundation of these systems relies heavily on asymmetric cryptography (like RSA and ECDSA). However, these algorithms are mathematically vulnerable to a sufficiently powerful future quantum computer running Shor's algorithm.</p> <p>This creates the \"Harvest Now, Decrypt Later\" threat. Hostile state actors are currently intercepting and storing encrypted communications traversing the internet. While they cannot break the ECDSA signatures today, they simply warehouse the data until quantum computers mature, allowing them to forge historical trust chains or decrypt past communications retroactively.</p>"},{"location":"insights/quantum-key-distribution/#the-solution-quantum-key-distribution-qkd-and-pqc","title":"The Solution: Quantum Key Distribution (QKD) and PQC","text":"<p>To secure Sovereign Trust Anchors against quantum threats, the architecture must evolve to utilize Post-Quantum Cryptography (PQC) and Quantum Key Distribution (QKD).</p>"},{"location":"insights/quantum-key-distribution/#1-quantum-key-distribution-qkd","title":"1. Quantum Key Distribution (QKD)","text":"<p>QKD uses the fundamental principles of quantum mechanics (specifically, that observing a quantum state changes it) to securely distribute symmetric encryption keys over fiber optic networks. If an adversary attempts to eavesdrop on the key exchange, the quantum state collapses, the error rate spikes, and the system instantly alerts administrators and aborts the key creation. This guarantees mathematically un-interceptable symmetric keys.</p>"},{"location":"insights/quantum-key-distribution/#2-post-quantum-cryptography-pqc","title":"2. Post-Quantum Cryptography (PQC)","text":"<p>For asymmetric operations (like digital signatures on an SD-JWT), NIST has standardized new algorithms (such as ML-DSA / Dilithium) that rely on extremely complex mathematical problems (like lattice-based cryptography) that even quantum computers struggle to solve efficiently.</p>"},{"location":"insights/quantum-key-distribution/#use-case-securing-national-trust-anchors","title":"Use Case: Securing National Trust Anchors","text":"<p>A national government is deploying a digital identity wallet. The root trust anchors\u2014the OpenID Federation entity statements that prove a specific government agency is a legitimate issuer\u2014must be absolutely tamper-proof. Furthermore, the communication channels distributing these trust chains between internal government agencies traversing public infrastructure must be quantum-secure.</p> <ol> <li>QKD Backbone: Specialized optical hardware connects the Central Bank, the Identity Registry, and the Federation Hub. These nodes continuously generate pristine symmetric keys via QKD.</li> <li>Quantum-Secure Federation: The OpenID Federation 1.0 trust anchors (the Entity Statements managed by the root authority) are signed using NIST-approved post-quantum algorithms (ML-DSA).</li> <li>Encrypted Payloads: When a highly classified SD-JWT payload needs to be encrypted for a specific verifier (using JWE), the system calls out to the local QKD node to request a quantum-secure symmetric key, rather than relying on standard Diffie-Hellman key exchange over the internet.</li> </ol>"},{"location":"insights/quantum-key-distribution/#implementing-with-sdjwtnet","title":"Implementing with SdJwt.Net","text":"<p>The <code>SdJwt.Net</code> ecosystem is highly extensible, allowing you to swap out standard cryptographic providers for quantum-secure alternatives.</p>"},{"location":"insights/quantum-key-distribution/#custom-pqc-signatures","title":"Custom PQC Signatures","text":"<p>You can implement a custom <code>IJwtSigner</code> and <code>IJwtVerifier</code> that use NIST-approved post-quantum algorithms instead of standard ECDSA.</p> <pre><code>// Conceptual implementation of a Post-Quantum Signer\npublic class PostQuantumJwtSigner : IJwtSigner\n{\n    private readonly string _alg = \"ML-DSA-65\"; // Example PQC algorithm indicator\n\n    public string Algorithm =&gt; _alg;\n\n    public string Sign(string payload, SecurityKey key)\n    {\n        // Interop with a PQC library (e.g., BouncyCastle PQC or native HSM)\n        // to generate a lattice-based signature.\n        byte[] payloadBytes = Encoding.UTF8.GetBytes(payload);\n        byte[] pqcSignature = PqcNativeInterop.SignMlDsa(payloadBytes, key);\n\n        return Base64UrlEncoder.Encode(pqcSignature);\n    }\n}\n</code></pre>"},{"location":"insights/quantum-key-distribution/#qkd-key-resolution-for-jwe","title":"QKD Key Resolution for JWE","text":"<p>For symmetric encryption components (e.g., encrypting the SD-JWT payload), you can intercept the key resolution process. Create a <code>QkdKeyProvider</code> that calls out to the local QKD node appliance via a standard API (like the ETSI QKD API standard) to request a key for the transaction.</p> <pre><code>public class QkdKeyProvider : ISymmetricKeyResolver\n{\n    private readonly HttpClient _qkdNodeClient;\n\n    public QkdKeyProvider(HttpClient qkdNodeClient)\n    {\n        _qkdNodeClient = qkdNodeClient;\n    }\n\n    public async Task&lt;byte[]&gt; ResolveKeyAsync(string verifierEntityId)\n    {\n        // Call the ETSI standard QKD REST API deployed on the local optical node\n        var response = await _qkdNodeClient.GetAsync($\"/api/v1/keys/{verifierEntityId}/request\");\n        response.EnsureSuccessStatusCode();\n        var keyData = await response.Content.ReadFromJsonAsync&lt;QkdKeyResponse&gt;();\n\n        return Convert.FromBase64String(keyData.KeyMaterial);\n    }\n}\n</code></pre> <p>By integrating these components, an <code>SdJwt.Net</code> deployment can achieve true HAIP Level 3 Sovereign compliance, ensuring trust infrastructure remains unbreakable even in a post-quantum world.</p>"},{"location":"insights/versioning-and-release-strategy/","title":"Auto-Versioning and Release Strategy for SD-JWT .NET","text":"<p>As the SD-JWT .NET ecosystem grows, manually managing version strings in <code>.csproj</code> files and hand-writing <code>CHANGELOG.md</code> becomes error-prone and tedious. To ensure a smooth, automated, and error-free release cycle, adopting robust auto-versioning and release strategies is highly recommended.</p> <p>Below is an analysis of the current state, alongside the recommended industry-standard strategies for .NET OSS libraries.</p>"},{"location":"insights/versioning-and-release-strategy/#1-current-state-analysis","title":"1. Current State Analysis","text":"<ul> <li>Versioning: All versions are currently hardcoded as <code>&lt;Version&gt;1.0.0&lt;/Version&gt;</code> in every <code>src/*.csproj</code>. This leads to missed version bumps, or instances where a release is cut but the package metadata retains older versions, producing the warnings seen in CI.</li> <li>Changelog: Hand-written. While it adheres to \"Keep a Changelog\", maintaining it manually guarantees drift and merge conflicts when multiple PRs are generated simultaneously.</li> <li>Releasing: Handled manually via GitHub. The tag and release must be perfectly synced with the code state.</li> </ul>"},{"location":"insights/versioning-and-release-strategy/#2-recommended-strategy-minver-release-please","title":"2. Recommended Strategy: MinVer + Release Please","text":"<p>The absolute best-in-class workflow for modern .NET ecosystem libraries combines two powerful, lightweight tools: MinVer and Google's Release Please.</p>"},{"location":"insights/versioning-and-release-strategy/#end-to-end-automated-release-workflow","title":"End-to-End Automated Release Workflow","text":"<pre><code>flowchart TD\n    Dev[Developer commits&lt;br/&gt;feat: Add OID4VP support] --&gt;|Push to main| GH[GitHub]\n\n    GH --&gt; CI[CI Pipeline&lt;br/&gt;.NET CI/CD]\n    CI --&gt; Tests[Unit + Integration Tests]\n    Tests --&gt; RP[Release Please Action]\n\n    RP --&gt;|Analyzes commit history| RPR[Release PR&lt;br/&gt;chore: release 1.2.0]\n    RPR --&gt;|Maintainer reviews| Merge{Merge&lt;br/&gt;Release PR?}\n\n    Merge --&gt;|Yes| Tag[Git Tag v1.2.0&lt;br/&gt;GitHub Release created]\n    Merge --&gt;|No - keep accumulating| GH\n\n    Tag --&gt; ReleaseCI[Release CI Pipeline]\n    ReleaseCI --&gt; MinVer[MinVer reads v1.2.0 tag]\n    MinVer --&gt; Build[dotnet build&lt;br/&gt;PackageVersion=1.2.0]\n    Build --&gt; Pack[dotnet pack&lt;br/&gt;SdJwt.Net.1.2.0.nupkg]\n    Pack --&gt; OIDC[NuGet Trusted Publishing&lt;br/&gt;OIDC - no secrets]\n    OIDC --&gt; NuGet[NuGet.org Published]\n\n    style Tag fill:#1b4332,color:#fff\n    style NuGet fill:#d62828,color:#fff\n    style OIDC fill:#40916c,color:#fff</code></pre>"},{"location":"insights/versioning-and-release-strategy/#a-auto-versioning-minver","title":"A. Auto-Versioning: <code>MinVer</code>","text":"<p>MinVer is a minimalist tool that automatically versions your .NET assemblies and NuGet packages based purely on Git tags.</p> <p>How it works:</p> <ol> <li>Add the <code>MinVer</code> package to <code>Directory.Build.props</code>.</li> <li>Remove all <code>&lt;Version&gt;</code> tags and hardcoded metadata from all <code>.csproj</code> files.</li> <li>When you build, <code>MinVer</code> finds the latest Git tag starting with <code>v</code> (e.g., <code>v1.1.0</code>), calculates distance if there are subsequent commits, and sets the <code>AssemblyVersion</code>, <code>FileVersion</code>, <code>PackageVersion</code>, and <code>Version</code> properties dynamically during build.</li> </ol> <p>Benefits:</p> <ul> <li>Single source of truth (Git tags).</li> <li>No more commit noise just to bump a <code>.csproj</code> version.</li> <li>Excellent support for pre-releases (<code>v1.2.0-beta.1</code>).</li> </ul>"},{"location":"insights/versioning-and-release-strategy/#b-automated-changelog-release-release-please","title":"B. Automated Changelog &amp; Release: <code>Release Please</code>","text":"<p>Release Please is a GitHub action that automates semantic versioning based on \"Conventional Commits\" (e.g., <code>feat: Add OID4VP support</code>, <code>fix: Patch nonce validation</code>).</p> <p>How it works:</p> <ol> <li>As PRs are merged to <code>main</code>, Release Please analyzes the commit titles.</li> <li>It opens an automated \"Release PR\" (e.g., <code>chore: release 1.2.0</code>). This PR updates <code>CHANGELOG.md</code> automatically by grouping up all features, fixes, and breaking changes.</li> <li>When a maintainer is ready to release, they simply merge this Release PR.</li> <li>Release Please then automatically creates the GitHub Release, assigns the Git tag (<code>v1.2.0</code>), and triggers your CI pipeline.</li> <li>Your CI pipeline runs, <code>MinVer</code> picks up the new <code>v1.2.0</code> tag, builds the NuGet packages with version <code>1.2.0</code>, and uses NuGet Trusted Publishing (OIDC) to securely push to NuGet.org.</li> </ol> <p>Benefits:</p> <ul> <li>Completely eliminates manual <code>CHANGELOG.md</code> editing.</li> <li>Mathematically determines semantic version changes (Major/Minor/Patch) based on commit types.</li> <li>Provides a clean, visible governance model (the Release PR acts as the final sign-off before publishing).</li> </ul>"},{"location":"insights/versioning-and-release-strategy/#3-alternative-approaches","title":"3. Alternative Approaches","text":""},{"location":"insights/versioning-and-release-strategy/#release-drafter-minver","title":"Release Drafter + MinVer","text":"<p>Instead of Release Please and Conventional Commits, you can use Release Drafter, which creates GitHub Draft Releases based on PR labels (e.g., <code>bug</code>, <code>enhancement</code>).</p> <ul> <li>Pros: Doesn't enforce rigid commit naming standards on contributors.</li> <li>Cons: Still requires a human to manually publish the draft release, and manually update the <code>CHANGELOG.md</code> file in the repo.</li> </ul>"},{"location":"insights/versioning-and-release-strategy/#nerdbankgitversioning-nbgv","title":"Nerdbank.GitVersioning (NBGV)","text":"<p>An alternative to MinVer. It uses a <code>version.json</code> file to track versions and calculates a unique build number per commit.</p> <ul> <li>Pros: Extremely powerful, tracks branch versions explicitly.</li> <li>Cons: Highly pervasive, modifies git history, and arguably too heavy for a mostly linear OSS project compared to MinVer.</li> </ul>"},{"location":"insights/versioning-and-release-strategy/#4-proposed-implementation-steps-if-approved","title":"4. Proposed Implementation Steps if Approved","text":"<p>If you choose to adopt the MinVer + Release Please recommendation, here are the steps we would take:</p> <ol> <li>Introduce Conventional Commits: Update <code>CONTRIBUTING.md</code> to request PRs follow conventional commits (or use PR titles).</li> <li>Add MinVer: Add <code>&lt;PackageReference Include=\"MinVer\" Version=\"4.3.0\" PrivateAssets=\"all\" /&gt;</code> to <code>Directory.Build.props</code> and delete all <code>&lt;Version&gt;</code> tags in the SDKs.</li> <li>Configure Release Please: Add <code>.github/workflows/release-please.yml</code> to set up the automated PR/Changelog creation.</li> <li>Refactor Release CI: Update the existing <code>release.yml</code> so that it triggers exclusively on newly published GitHub Releases (which Release Please creates), invoking <code>MinVer</code> and Trusted Publishing gracefully.</li> </ol>"}]}